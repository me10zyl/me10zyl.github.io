<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rainy Mood - allyn 的日志</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zengyilun.com/"/>
  <updated>2018-11-06T01:53:43.751Z</updated>
  <id>http://www.zengyilun.com/</id>
  
  <author>
    <name>allyn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIUI_QQ耗电毒瘤关闭没用的功能节约电量</title>
    <link href="http://www.zengyilun.com/Hexo1/"/>
    <id>http://www.zengyilun.com/Hexo1/</id>
    <published>2018-11-06T01:42:09.000Z</published>
    <updated>2018-11-06T01:53:43.751Z</updated>
    
    <content type="html"><![CDATA[<p>手机QQ耗电毒瘤，关闭没用的功能节省电量</p><a id="more"></a><p><img src="/images/Hexo1/20181106094846183.png" alt=""></p><ol><li><p>关闭所有没用的动态</p><p>  动态-&gt;右上角点更多-&gt;关闭没用的动态<br>  特别是运动要关闭，计步是非常耗电的</p></li><li><p>把所有不需要的接受消息的群全部屏蔽</p></li><li>MIUI 安全中心-&gt;电量-&gt;QQ智能省电</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手机QQ耗电毒瘤，关闭没用的功能节省电量&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.zengyilun.com/tags/Android/"/>
    
      <category term="QQ" scheme="http://www.zengyilun.com/tags/QQ/"/>
    
  </entry>
  
  <entry>
    <title>Windows/Mac下黑苹果简易安装步骤【Intel HD Graphics 630】</title>
    <link href="http://www.zengyilun.com/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
    <id>http://www.zengyilun.com/黑苹果/</id>
    <published>2018-10-15T02:07:07.000Z</published>
    <updated>2018-10-15T02:41:50.421Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="http://bbs.pcbeta.com/" target="_blank" rel="noopener">http://bbs.pcbeta.com/</a> 远景论坛</li><li><a href="https://imac.hk/" target="_blank" rel="noopener">https://imac.hk/</a> 黑苹果乐园</li><li><a href="https://www.tonymacx86.com/" target="_blank" rel="noopener">https://www.tonymacx86.com/</a> tonymacx86</li></ul><a id="more"></a><h2 id="Windows-下安装黑苹果"><a href="#Windows-下安装黑苹果" class="headerlink" title="Windows 下安装黑苹果:"></a>Windows 下安装黑苹果:</h2><p>硬件材料准备：两个大于8G的U盘。【若是VGA显示器，需配备PCI/24 转 VGA 转接头（因为是核显，Mac不再支持核显VGA，若是独显则不需要）】</p><ol><li>首先下载 Mac with Clover</li><li>使用TransMac 将镜像拷贝进U盘</li><li>制作WinPE的U盘，插入U盘，重启。进入WindowsPE系统，将要安装MAC的磁盘，MBR转换为GUID分区。</li><li>预留一个300MB的ESP分区，并且格式化一个HFS+的80G硬盘给苹果安装系统。</li><li>重启，进入CloverU盘，磁盘工具，格式化HFS+的80G硬盘为苹果日志式硬盘。</li><li>开始安装苹果，等待安装。</li><li>再此进入WinPE的U盘，将CloverU盘的EFI文件夹拷贝到硬盘的ESP分区，以便脱离U盘可以使用硬盘驱动。重启。</li><li>使用F11 BootMenu进入Clover引导，运行Mac，开始正式安装Mac，等待安装完成。</li><li>进入苹果系统，发现浏览器有花屏，下载Nvida WebDriver显卡驱动，重启。</li><li>再次进入苹果系统，无限循环，无法进入系统，重启，进入WinPEU盘。</li><li>更改ESP的Clover的plist配置，找到并配置<code>&lt;key&gt;Arguments&lt;key&gt; &lt;string&gt;nvda_drv=1 kext-dev-mode=1&lt;/string&gt;</code>，重启进入MAC。</li><li>能再次进入苹果，并且浏览器无花屏，安装完成！</li></ol><h2 id="Mac-下重装黑苹果"><a href="#Mac-下重装黑苹果" class="headerlink" title="Mac 下重装黑苹果"></a>Mac 下重装黑苹果</h2><p>此步骤用于已经安装了黑苹果，想重装系统的方式</p><h4 id="一、安装系统"><a href="#一、安装系统" class="headerlink" title="一、安装系统"></a>一、安装系统</h4><p>无论白苹果、黑苹果，首先需要下载一个新系统，在应用商店搜索 OS X，你就会看到目前最新系统，点 download 下载。</p><h4 id="二、制作U盘"><a href="#二、制作U盘" class="headerlink" title="二、制作U盘"></a>二、制作U盘</h4><p>官方教程： <a href="https://support.apple.com/en-us/HT201372" target="_blank" rel="noopener">https://support.apple.com/en-us/HT201372</a></p><ol><li><p>第一步格式化 U 盘，调出spotlight (Ctrl + Space)，搜索 disk utility，找到自己的 U 盘，格式化为 GUID ，janary 格式，名称可以默认Untitled</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath &quot;/Applications/Install OS X El Capitan.app&quot;</span><br></pre></td></tr></table></figure></li><li><p>白苹果的启动盘就制作完成了。</p></li></ol><h4 id="三、插入U盘，启动-Boot-Mac-OS-Install-From-Mac-OS-Install-重装系统"><a href="#三、插入U盘，启动-Boot-Mac-OS-Install-From-Mac-OS-Install-重装系统" class="headerlink" title="三、插入U盘，启动 Boot Mac OS Install From Mac OS Install 重装系统"></a>三、插入U盘，启动 Boot Mac OS Install From Mac OS Install 重装系统</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bbs.pcbeta.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bbs.pcbeta.com/&lt;/a&gt; 远景论坛&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imac.hk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://imac.hk/&lt;/a&gt; 黑苹果乐园&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.tonymacx86.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.tonymacx86.com/&lt;/a&gt; tonymacx86&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="hackintosh" scheme="http://www.zengyilun.com/tags/hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>todo</title>
    <link href="http://www.zengyilun.com/todo/"/>
    <id>http://www.zengyilun.com/todo/</id>
    <published>2018-10-12T01:19:04.375Z</published>
    <updated>2018-10-12T01:19:04.375Z</updated>
    
    <content type="html"><![CDATA[<p>现在开始看 HTTP 权威指南…《编码》暂时放一段落了。。。(MC实现进度拖延导致后面章节很难看)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在开始看 HTTP 权威指南…《编码》暂时放一段落了。。。(MC实现进度拖延导致后面章节很难看)&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>快速写日志，Hexo的专用编辑器 - HexoEditor</title>
    <link href="http://www.zengyilun.com/HexoEditor/"/>
    <id>http://www.zengyilun.com/HexoEditor/</id>
    <published>2018-09-29T01:16:08.000Z</published>
    <updated>2018-10-12T01:19:04.379Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">https://github.com/zhuzhuyule/HexoEditor</a><br>Hexo Editor, 专门为写 Hexo日志而生， 改编自MoeEditor，支持 Markdown，Latex 等。<br><a id="more"></a><br>下载地址：<br>Windows x64: <a href="https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_win_x64.exe" target="_blank" rel="noopener">https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_win_x64.exe</a><br>Mac x64:<a href="https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_mac_x64.dmg" target="_blank" rel="noopener">https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_mac_x64.dmg</a><br><img src="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/main.png" alt="1"></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>HexoEditor 独有功能<ul><li>实时预览</li><li>支持 Hexo Tag/Filter/Renderer </li><li>支持 Hexo <code>_config.yml</code></li><li>Hexo source 中快速新建POST</li><li>快速修改文件名 (在Hexo文件中编辑)  </li><li>快速部署 Hexo</li><li>快速 Hexo 命令 <code>hexo d</code>,<code>hexo g</code>,<code>hexo s</code>,<code>hexo clean</code></li><li>在Markdown中自动添加图片<ul><li>支持图片拖拽</li><li>支持剪切板粘贴 [重点]</li></ul></li><li>支持图片上传 (一步上传)<ul><li>支持 <a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a> </li><li>支持 <a href="https://portal.qiniu.com" target="_blank" rel="noopener">QiNiu</a> </li><li>支持 <a href="https://console.cloud.tencent.com" target="_blank" rel="noopener">Tencent</a> </li></ul></li><li>快速打开 (公共目录，公共URL)</li><li>同步滚动</li></ul></li><li>HexoEditor (继承 <a href="https://github.com/Moeditor/Moeditor" target="_blank" rel="noopener">Moeditor</a>)<ul><li>GitHub 风格的 Markdown</li><li>TeX 数学表达式</li><li>UML 图</li><li>代码高亮</li><li>读/写/预览 模式</li><li>自定义字体 / 行高 / 大小</li><li>自定义主题</li><li>代码高亮主题 (powered by <a href="https://highlightjs.org/" target="_blank" rel="noopener">highlight.js</a>)</li><li>自动重加载</li><li>本地化</li><li>专注模式</li></ul></li></ul><p>Electron 构建，理论上是跨平台的，Windows Mac都能使用。<br><img src="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/menu.png" alt="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/menu.png"></p><p>缺点：</p><ul><li>一键部署不是很好用，没有自定义添加外部程序的功能 </li><li>粘贴图片后地址为/pic.png，而不是/images/pic.png</li><li>最好有一个一键打开Hexo根目录命令行的功能</li><li>hexo 命令执行好像还没成功过，已经配了Hexo的_config.yml，无限操作执行中…如图所示：<br><img src="/images/HexoEditor/20180929093043591.png" alt="1"></li></ul><p>使用此编辑器后写博客的步骤简化为：</p><ol><li>打开 Alfred, 输入 hexo 打开 HexoEditor<br><img src="/images/HexoEditor/20180929093606497.png" alt="1"></li><li>新建 Post，在_post文件夹自动生成文件，并含有date，修改title, tag，文件名同步 title 修改。<br><img src="/images/HexoEditor/20180929093729763.png" alt="2"><br><img src="/images/HexoEditor/20180929093910225.png" alt="3"></li><li>写博客途中有图片直接截图点粘贴，自动生成图片和路径，把路径前缀加上/images<br>如 <code>![](/HexoEditor/20180929094201824.png)</code>，其中HexoEditor为标题名称，需要手动修改为<code>![](/images/HexoEditor/20180929094201824.png)</code></li><li>保存，打开终端，提交代码</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/zhuzhuyule/HexoEditor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zhuzhuyule/HexoEditor&lt;/a&gt;&lt;br&gt;Hexo Editor, 专门为写 Hexo日志而生， 改编自MoeEditor，支持 Markdown，Latex 等。&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://www.zengyilun.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>jQuery选择器练习</title>
    <link href="http://www.zengyilun.com/jQuery%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%83%E4%B9%A0/"/>
    <id>http://www.zengyilun.com/jQuery选择器练习/</id>
    <published>2018-09-28T05:49:36.000Z</published>
    <updated>2018-10-12T01:19:04.375Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zengyilun.com/demos/html5demos/4/jqueryselectors/index.html">https://www.zengyilun.com/demos/html5demos/4/jqueryselectors/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zengyilun.com/demos/html5demos/4/jqueryselectors/index.html&quot;&gt;https://www.zengyilun.com/demos/html5demos/4/jquerysele
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GitHub + Hexo + Travis 博客快速搭建指南</title>
    <link href="http://www.zengyilun.com/hexo/"/>
    <id>http://www.zengyilun.com/hexo/</id>
    <published>2018-09-28T01:26:16.000Z</published>
    <updated>2018-10-12T01:19:04.379Z</updated>
    
    <content type="html"><![CDATA[<p>1.注册一个Github账号<br>2.创建一个名为 <code>&lt;username&gt;.github.io</code> 的仓库，其中<code>&lt;username&gt;</code>为你的Github账号，这个仓库不能随便取名。这个仓库用于存储 Hexo 生成的静态HTML(master分支)。<br><a id="more"></a><br><img src="/images/hexo/20180928094051867.png" alt=""><br>3.创建一个名为 <code>blog</code> 的仓库，这个仓库也能叫其他名称，用于存储 Hexo 博客源文件。<br>4.安装 Hexo，前提是你已经安装了必备程序Nodejs</p><pre><code>npm install -g hexo-cli</code></pre><blockquote><p>注： 安装 Node.js 的最佳方式是使用 nvm。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br><span class="line">nvm install stable</span><br></pre></td></tr></table></figure></p></blockquote><p>5.找到一个文件夹 blog/，执行Hexo 博客创建命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>6.在 blog/ 中添加 <code>gulpfile.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'hexo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">  exec(<span class="string">'hexo clean &amp;&amp; hexo g'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">return</span> cb(err);</span><br><span class="line">cb();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'hexo'</span>]);</span><br></pre></td></tr></table></figure></p><p>7.在 blog/ 中添加 <code>.travis.yml</code>，按需修改<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  global:</span></span><br><span class="line"><span class="attr">      - GH_PAGES_REPO:</span> <span class="string">me10zyl/me10zyl.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"node"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="bullet">-rf</span> <span class="string">node_modules/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">me10zyl</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">me10zyl@qq.com</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  github_token:</span> <span class="string">$GH_TOKEN</span> <span class="comment"># Set in travis-ci.org dashboard</span></span><br><span class="line"><span class="attr">  target_branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  local_dir:</span> <span class="string">dist</span></span><br><span class="line"><span class="attr">  fqdn:</span> <span class="string">www.zengyilun.com</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">$GH_PAGES_REPO</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p><p>7.登陆 <a href="http://travis-ci.org" target="_blank" rel="noopener">travis-ci.org</a>，登陆你的Github账号<br>8.GitHub生成 Travis Access Token<br><img src="/images/hexo/20180928113319644.png" alt="1"></p><p><img src="/images/hexo/20180928113400040.png" alt="2"><br>9.在 Travis 仓库配置 $GH_TOKEN 环境变量，拷贝刚才生成的Access Token<br><img src="/images/hexo/20180928113446154.png" alt="3"><br>10.提交代码，等待1分钟，成功访问你的博客： <a href="http://me10zyl.github.io" target="_blank" rel="noopener">http://me10zyl.github.io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.注册一个Github账号&lt;br&gt;2.创建一个名为 &lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 的仓库，其中&lt;code&gt;&amp;lt;username&amp;gt;&lt;/code&gt;为你的Github账号，这个仓库不能随便取名。这个仓库用于存储 Hexo 生成的静态HTML(master分支)。&lt;br&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://www.zengyilun.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>汇编基础</title>
    <link href="http://www.zengyilun.com/%E6%B1%87%E7%BC%96/"/>
    <id>http://www.zengyilun.com/汇编/</id>
    <published>2018-07-12T01:30:46.000Z</published>
    <updated>2018-10-12T01:19:04.379Z</updated>
    
    <content type="html"><![CDATA[<p>一个CPU的寻址能力为8K，那么它的地址总线的宽度为 13<br>8KB = 8192 Byte = 2^13 Byte，即宽度为13<br>什么是16位CPU？<br><a id="more"></a><br>概括地讲，16位结构（16位机、字长为16，与16位结构相同）描述了一个CPU具有下面既方便的结构特性。</p><pre><code>+ 运算器一次最多可以处理16位数据+ 寄存器最大宽度为16位+ 寄存器与运算器之间的通路为16位</code></pre><p> 也就是说，能够一次性处理、传输、暂时存储的最大长度为16<br>8086CPU 的几条汇编指令</p><pre><code>mov ax,18add ax,8sub ax,8jmp 2AE3:3 # jmp 段地址：偏移地址，执行后CS=2AE3H，IP=0003Hjmp ax # 执行前，ax=1000H,CS=2000H,IP=0003H       # 执行后，ax=1000H,CS=2000H,IP=1000H       # jmp 寄存器 功能为 用寄存器中的值修改IPpush bx # 将 bx 的数据 入栈pop ax # 将栈顶的数据放入ax</code></pre><p>8086CPU 寄存器<br>    CS：CS为代码段寄存器<br>    IP：IP为指令指针寄存器<br>    假设CS中的内容为M，IP中的内容为N，8086CPU将从内存M x 16 + N 单元开始，读取一条指令并执行。<br>    DS: 通常用来存放要访问数据的段地址<br>    mov bx 1000h<br>    mov ds, bx<br>    mov al, [0]<br>    mov [0],cs<br>    上面指令将1000h(1000:0)读入al中<br>    [···]表示一个内存单元偏移地址，8086CPU的段地址取DS中的值<br>    SS 栈顶元素段地址<br>    SP 栈顶元素偏移地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个CPU的寻址能力为8K，那么它的地址总线的宽度为 13&lt;br&gt;8KB = 8192 Byte = 2^13 Byte，即宽度为13&lt;br&gt;什么是16位CPU？&lt;br&gt;
    
    </summary>
    
    
      <category term="汇编" scheme="http://www.zengyilun.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>jrebel破解配置</title>
    <link href="http://www.zengyilun.com/jrebel%E7%A0%B4%E8%A7%A3%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.zengyilun.com/jrebel破解配置/</id>
    <published>2018-07-10T07:22:31.000Z</published>
    <updated>2018-10-12T01:19:04.378Z</updated>
    
    <content type="html"><![CDATA[<p>要破解jrebel，秩序在license server 填上反向代理idea.lanyus.com 的地址，例如配置一个nginx配置<br><a id="more"></a><br>jrebel.conf<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  jrebel.xxx.cn;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://idea.lanyus.com/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span>  /54319d1a-<span class="number">0344</span>-48a9-a70c-265ce2a887cc &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://idea.lanyus.com/;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>反代配好后，更改hosts  127.0.0.1 jrebel.xxx.cn<br>在jrebel license server 上填写<code>http://jrebel.xxx.cn/54319d1a-0344-48a9-a70c-265ce2a887cc</code> 就激活成功了，激活路径最好加上GUID，不然有可能失败</p><ul><li>激活后记得关闭jrebel的自动上传数据<br><img src="/images/2018-07-10-jrebel破解配置/20180710033210430.png" alt="aaaaaa"><br>JRebel -&gt; workoffline<br><img src="/images/2018-07-10-jrebel破解配置/20180710033244732.png" alt="aaaaaa"><br>JRebel -&gt; Advanced -&gt; Disable reporting</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要破解jrebel，秩序在license server 填上反向代理idea.lanyus.com 的地址，例如配置一个nginx配置&lt;br&gt;
    
    </summary>
    
    
      <category term="intellij idea" scheme="http://www.zengyilun.com/tags/intellij-idea/"/>
    
      <category term="jrebel" scheme="http://www.zengyilun.com/tags/jrebel/"/>
    
  </entry>
  
  <entry>
    <title>Intellij Idea - 理解 artifact 并与之工作</title>
    <link href="http://www.zengyilun.com/idea-artifact/"/>
    <id>http://www.zengyilun.com/idea-artifact/</id>
    <published>2017-11-01T07:41:43.000Z</published>
    <updated>2018-10-12T01:19:04.378Z</updated>
    
    <content type="html"><![CDATA[<p>Artifact - Intellij Idea 与软件工程中一个重要的概念，本文详细解释了Artifact在Intellij Idea 的存在形式与应用。</p><a id="more"></a><h2 id="什么是-artifact"><a href="#什么是-artifact" class="headerlink" title="什么是 artifact?"></a>什么是 artifact?</h2><p>Artifact 是你项目中的资源集合，用于测试、部署、发布你的软件解决方案。（例如一堆编译好的 Java 类 或者 一个打包的Java程序， 一个文件夹结构的网页应用 或者 一个打包的网页应用，等等）。  </p><p>文件夹结构的 Artifact 或者 打包的结构包括以下组件：</p><ul><li>一个或多个module的编译输出</li><li>module 依赖库 中包含的 库</li><li>资源集合 （网页、图片、描述文件等）</li><li>其他 Artifact</li><li>个别文件，目录和压缩包</li></ul><h2 id="配置-artifact"><a href="#配置-artifact" class="headerlink" title="配置 artifact"></a>配置 artifact</h2><p>通过 <code>File | Project Structure | Artifacts</code> 配置Artifact 来指定其结构和内容</p><h2 id="构建-artifacts"><a href="#构建-artifacts" class="headerlink" title="构建 artifacts"></a>构建 artifacts</h2><ol><li>通过 <code>Build | Build Artifacts</code> 构建</li><li>通过 <code>Run | Debug</code> 中的 Before  Lauch ，添加 <code>Build &lt;ArtifactName&gt; artifact</code> 任务， artifact 会在程序运行或者调试的时候 构建</li><li>artifact 构建默认输出目录为<code>out/artifacts/&lt;artifact_dir&gt;</code>，但是如果有Maven 的话输入为 <code>target/&lt;artifact_dir&gt;</code></li></ol><h2 id="构建选项"><a href="#构建选项" class="headerlink" title="构建选项"></a>构建选项</h2><p>构建一个Artifact (Build | Build Artifacts)，有如下的选项：</p><ul><li><strong>Build.</strong> 第一次使用，整个 artifact 都构建。下次使用， 只有一部分的改变会被构建 因为 最后的构建已经添加到 输出目录了。</li><li><strong>Rebuild.</strong> 整个 artifact 都构建。实际上，先使用了<code>clean</code>再使用<code>build</code></li><li><strong>Clean.</strong> 删除输出目录的所有artifact</li><li><strong>Edit.</strong> 编辑 artifact configuration</li></ul><h2 id="运行-Jar-Artifact"><a href="#运行-Jar-Artifact" class="headerlink" title="运行 Jar Artifact"></a>运行 Jar Artifact</h2><p> 通过 JAR Application run configurations 运行。</p><ol><li>打开 Run/Debug Configurations?对话框 (e.g. Run | Edit Configurations).</li><li>点 + 并选择 JAR Application.</li></ol><h2 id="部署-artifacts-到application-servers-和-cloud-platforms"><a href="#部署-artifacts-到application-servers-和-cloud-platforms" class="headerlink" title="部署 artifacts 到application servers 和 cloud platforms"></a>部署 artifacts 到application servers 和 cloud platforms</h2><p>有很多 artifact 格式 （比如 WAR，Exploded WAR, EAR, Exploded EAR) 都适合部署到程序服务器和云服务器，下面是部署步骤：</p><ol><li>在服务器 或者 远程服务器 run/debug configuration，指定 artifact 来部署。</li><li>运行 run/debug configuration 或者 在 <strong>Application Servers</strong>, <strong>Run</strong> or <strong>Debug</strong> tool window 上使用 <strong>Deploy</strong> 图标。</li></ol><h2 id="artifact-与-exploded-artifact-的区别"><a href="#artifact-与-exploded-artifact-的区别" class="headerlink" title="artifact 与 exploded artifact 的区别"></a>artifact 与 exploded artifact 的区别</h2><p>artifact 是 exploded artifact 打包后的产品， 而 exploded artifact 是文件夹结构的，除了这个区别，在Tomcat 部署这两种 artifact 的时候，调试的时候也有一定区别。详见 <a href="/idea-tomcat">Intelij Idea 使用 Tomcat 运行/调试 Web 应用 （超详细）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Artifact - Intellij Idea 与软件工程中一个重要的概念，本文详细解释了Artifact在Intellij Idea 的存在形式与应用。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.zengyilun.com/categories/linux/"/>
    
    
      <category term="openvpn" scheme="http://www.zengyilun.com/tags/openvpn/"/>
    
      <category term="linux" scheme="http://www.zengyilun.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Intelij Idea 使用 Tomcat 运行/调试 Web 应用 （超详细）</title>
    <link href="http://www.zengyilun.com/idea-tomcat/"/>
    <id>http://www.zengyilun.com/idea-tomcat/</id>
    <published>2017-11-01T07:08:08.000Z</published>
    <updated>2018-10-12T01:19:04.378Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事必先利其器，本文拟用 Intellij Idea 来启动 Tomcat 运行/调试 Web 应用，深入 Idea 与 Tomcat 结合调试，减少项目部署时间。</p><a id="more"></a><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ol><li>Run Configuration -&gt; 新建 Tomcat Run Configuration</li></ol><p><img src="/images/idea/1.png" alt="image"></p><ol><li><p>选择当更新操作(Ctrl + F10)或者 Intellij Idea 失去焦点的时候更新Tomcat 中的 classes和资源（热交换）<br><img src="/images/idea/2.png" alt="image"></p></li><li><p>选择部署的artifact，这里选 war exploded, 为什么不选 war, 因为war是war exploded 打包后的， war exploded 不打包，而且 war 不支持 静态资源的热部署<br><img src="/images/idea/3.png" alt="image"></p></li></ol><ol><li>Run/Debug </li></ol><p><img src="/images/idea/4.png" alt="image"></p><h2 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h2><p>设置 Tomcat 配置的时候可以看到， On Update action 和 On frame deactivation， 这个是指什么，接下来会介绍。</p><h3 id="On-‘Update’-action"><a href="#On-‘Update’-action" class="headerlink" title="On ‘Update’ action"></a>On ‘Update’ action</h3><p>顾名思义，更新操作，是指 ‘Update application’， 快捷键为 Ctrl + F10 ，或者点击运行/调试 View左下角，与 Build Project/Module(Ctrl + F9) 不是同一个概念</p><p><img src="/images/idea/5.png" alt="image"></p><p>对于 exploded artifacts ， 可选的选项为</p><ul><li>Update Resources. 所有改变的资源都更新（CSS、HTML、JS等）</li><li>Update classes and resources. 所有改变的资源和改变的Java 类都重新编译更新  </li></ul><blockquote><p>在 Debug 模式下, 更新的类可以热交换(hot swapped). 在 Run 模式下, IntelliJ IDEA 只更新输出文件夹中的改变的类. 这个类实际上到底重载没有，取决于运行环境的兼容性。</p></blockquote><ul><li>Redeploy. 应用 artifact 重新构建和重新部署</li><li>Restart Server. 服务器重启，应用 artifact 重新构建和重新部署</li></ul><p>对于 packed artifacts （不带exploded的)，可选的选项为</p><ul><li>Hot swap classes. 改变的类重新编译和在运行时重加载. 只在 <strong>debug</strong> 模式下有用</li><li>Redeploy. 应用 artifact 重新构建和重新部署</li><li>Restart Server. 服务器重启，应用 artifact 重新构建和重新部署</li></ul><h2 id="On-frame-deactivation"><a href="#On-frame-deactivation" class="headerlink" title="On frame deactivation"></a>On frame deactivation</h2><p>这个名词的意思即 从Intellij idea 切换到其他程序，触发的操作。除了<br>Do nothing 选项，其他选项都跟 ‘On Update action’一致。</p><h2 id="Deploy-applications-configured-in-Tomcat-instance"><a href="#Deploy-applications-configured-in-Tomcat-instance" class="headerlink" title="Deploy applications configured in Tomcat instance"></a>Deploy applications configured in Tomcat instance</h2><p>勾选上这个选项，这样就会部署 tomcat 中的其他应用， 比如</p><ul><li>docs</li><li>examples</li><li>host-manager</li><li>manager</li><li>ROOT</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事必先利其器，本文拟用 Intellij Idea 来启动 Tomcat 运行/调试 Web 应用，深入 Idea 与 Tomcat 结合调试，减少项目部署时间。&lt;/p&gt;
    
    </summary>
    
      <category term="intellij idea" scheme="http://www.zengyilun.com/categories/intellij-idea/"/>
    
    
      <category term="intellij idea" scheme="http://www.zengyilun.com/tags/intellij-idea/"/>
    
      <category term="java" scheme="http://www.zengyilun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 搭建 OpenVPN 翻墙</title>
    <link href="http://www.zengyilun.com/openvpn/"/>
    <id>http://www.zengyilun.com/openvpn/</id>
    <published>2017-10-31T06:43:38.000Z</published>
    <updated>2018-10-12T01:19:04.378Z</updated>
    
    <content type="html"><![CDATA[<p>本文以 Ubuntu 为服务器搭建 OpenVPN 实现翻墙与外网客户端访问服务端内网。</p><a id="more"></a><h2 id="安装openvpn与easyrsa-（证书生成工具）-并启动"><a href="#安装openvpn与easyrsa-（证书生成工具）-并启动" class="headerlink" title="安装openvpn与easyrsa （证书生成工具） 并启动"></a>安装openvpn与easyrsa （证书生成工具） 并启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openvpn easy-rsa</span><br></pre></td></tr></table></figure><p>首先把配置文件模板拷贝到/etc/openvpn/目录下，再解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/</span><br><span class="line">sudo gzip -d /etc/openvpn/server.conf.gz</span><br></pre></td></tr></table></figure><p>然后把easy-rsa拷贝到openvpn的配置目录下，方便操作<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/openvpn/easy-rsa/</span><br><span class="line">cp -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa/</span><br></pre></td></tr></table></figure></p><p>切换到easy-rsa目录，并且清除之前生成的keys(如果有)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/easy-rsa/</span><br><span class="line">./clean-all</span><br><span class="line">./build-ca #生成ca证书</span><br></pre></td></tr></table></figure></p><p>生产服务器证书，这里有个坑，当询问到最后一步的时候一定要按y，不然会生成空的证书</p><blockquote><p>As in the previous step, most parameters can be defaulted. Two other queries require positive responses, “Sign the certificate? [y/n]” and “1 out of 1 certificate requests certified, commit? [y/n]”.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key-server myservername</span><br></pre></td></tr></table></figure><p>生成Diffie Hellman 参数(可能有点慢):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure><p>现在所有的证书都在 <code>/etc/openvpn/easy-rsa/keys/</code> 里了，现在需要拷贝出来，拷贝到 openvpn 配置文件夹里面 (/etc/openvpn)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd keys/</span><br><span class="line">cp myservername.crt myservername.key ca.crt dh2048.pem /etc/openvpn/</span><br></pre></td></tr></table></figure><p>最后，还需要生成一个秘钥 <code>ta.key</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --genkey --secret ta.key</span><br></pre></td></tr></table></figure><p>现在可以看到/etc/openvpn目录有的证书与秘钥如下：</p><p><code>myservername.crt myservername.key ca.crt dh2048.pem ta.key</code></p><p>现在开始修改openvpn配置文件，让配置文件对应刚刚拷贝过来的证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/openvpn/server.conf</span><br><span class="line"></span><br><span class="line">ca ca.crt</span><br><span class="line">cert myservername.crt</span><br><span class="line">key myservername.key</span><br><span class="line">dh dh2048.pem</span><br><span class="line">tls-auth ta.key 0</span><br></pre></td></tr></table></figure><p>现在服务器就配置完成了，启动试试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start openvpn@server</span><br></pre></td></tr></table></figure></p><p>启动成功！<br>看看日志:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status openvpn@server</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journal -u openvpn@server</span><br></pre></td></tr></table></figure></p><h2 id="制作客户端证书"><a href="#制作客户端证书" class="headerlink" title="制作客户端证书"></a>制作客户端证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/easy-rsa/</span><br><span class="line">./build-key client1</span><br></pre></td></tr></table></figure><p>然后把下列证书与秘钥传送到客户端所在机器</p><ol><li>/etc/openvpn/ca.crt</li><li>/etc/openvpn/easy-rsa/keys/client1.crt</li><li>/etc/openvpn/easy-rsa/keys/client1.key</li><li>/etc/openvpn/ta.key</li></ol><h2 id="Windows-客户端配置"><a href="#Windows-客户端配置" class="headerlink" title="Windows 客户端配置"></a>Windows 客户端配置</h2><p>1.先在官网下一份openvpn客户端，在安装目录找到sample-config文件夹，找到client.ovpn，拷贝到安装目录的config文件夹。</p><p>2.然后将服务器上制作的客户端证书与秘钥传送到config文件夹。</p><p>3.修改一下client.ovpn配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert client1.crt</span><br><span class="line">key client1.key</span><br><span class="line">tls-auth ta.key 1</span><br></pre></td></tr></table></figure></p><p>4.找到系统托盘，连接！连接成功，现在ping 10.8.0.x （openvpn服务器的IP) 成功，<strong>但是现在还不能翻墙</strong>！</p><h2 id="OpenVpn-翻墙配置"><a href="#OpenVpn-翻墙配置" class="headerlink" title="OpenVpn 翻墙配置"></a>OpenVpn 翻墙配置</h2><p>首先需要配置Ubuntu支持流量转发，编辑 /etc/sysctl.conf<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">net.ipv4.ip_forward=1</span></span><br></pre></td></tr></table></figure></p><p>把注释去掉，然后重新加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p><p>修改openvpn配置 <code>/etc/openvpn/server.conf</code>，使其重定向客户端流量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push &quot;redirect-gateway def1 bypass-dhcp&quot;</span><br></pre></td></tr></table></figure></p><p>修改dns<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push &quot;dhcp-option DNS 8.8.8.8&quot;</span><br></pre></td></tr></table></figure></p><p>重启openvpn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart openvpn@server</span><br></pre></td></tr></table></figure></p><p>现在用客户端连上发现不能上网了，只能访问openvpn这台机器！是因为openvpn把客户端的所有流量都转发了，但是服务端并没有配置流量转发到外网。  </p><p>设置 iptables 转发10.8.0.x 的所有流量到外网:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE</span><br></pre></td></tr></table></figure></p><p>现在访问Google，OK！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以 Ubuntu 为服务器搭建 OpenVPN 实现翻墙与外网客户端访问服务端内网。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.zengyilun.com/categories/linux/"/>
    
    
      <category term="openvpn" scheme="http://www.zengyilun.com/tags/openvpn/"/>
    
      <category term="linux" scheme="http://www.zengyilun.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Systemd 为 Shadowsocks 添加开机启动服务</title>
    <link href="http://www.zengyilun.com/systemd/"/>
    <id>http://www.zengyilun.com/systemd/</id>
    <published>2017-10-30T10:34:01.000Z</published>
    <updated>2018-10-12T01:19:04.378Z</updated>
    
    <content type="html"><![CDATA[<p>本文以 Shadowsocks 为例，如何使用 Systemd 为 Shadowsocks 添加开机启动，</p><a id="more"></a><h2 id="安装-Shadowsocks"><a href="#安装-Shadowsocks" class="headerlink" title="安装 Shadowsocks"></a>安装 Shadowsocks</h2><p>首先是下载 Shadowsocks</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shadowsocks</span><br></pre></td></tr></table></figure><p>安好shadowsocks后，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -k mypass</span><br></pre></td></tr></table></figure><p>这样就启动了一个 Shadowsocks 前台程序，即程序会占用终端的输出。当然可以使用<code>ssserver -k mypass -d start</code>自带的daemon后台程序托管Shadowsocks，但是本文的目的是使用Systemd来管理Shadowsocks并实现开机自动启动。</p><h2 id="使用-Systemd-托管-Shadowsocks"><a href="#使用-Systemd-托管-Shadowsocks" class="headerlink" title="使用 Systemd 托管 Shadowsocks"></a>使用 Systemd 托管 Shadowsocks</h2><p>想要成为Systemd 一个服务，可以通过在其指定目录下添加 systemd单元配置文件，即在<br><code>/usr/lib/system.d/system</code> 和 <code>/etc/system.d/system</code> 目录添加<br><code>ss.service</code>文件即可，<code>ss</code>则是这个服务的服务名</p><p>添加服务单元配置文件，首先需要一个systemd配置文件的模板，这里以ssh.service为例，复制一份ssh.service的模板再修改我们所需要的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl cat ssh.service &gt; /usr/lib/system.d/system/ss.service</span><br></pre></td></tr></table></figure><p>修改完毕的ss.service…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /lib/systemd/system/ss.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/ssserver -k mypass</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重新加载一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd daemon-reload</span><br></pre></td></tr></table></figure><p>查看已经加载的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status ss.service</span><br></pre></td></tr></table></figure><p>可以看到目前是inactive的，即还没有启动，现在启动这个服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ss.service</span><br></pre></td></tr></table></figure></p><p>现在还没有设置开机启动，可以看到状态是disabled</p><h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>使其开机自动启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable ss.service</span><br></pre></td></tr></table></figure></p><p>现在用<code>systemctl status ss.service</code>查看状态可以看到ss服务正在运行，并且最下方是它的日志</p><h2 id="维护Shadowsocks-访问-Shadowsocks-日志"><a href="#维护Shadowsocks-访问-Shadowsocks-日志" class="headerlink" title="维护Shadowsocks - 访问 Shadowsocks 日志"></a>维护Shadowsocks - 访问 Shadowsocks 日志</h2><p>如果遇到一些奇怪的情况，客户端使用这个ss服务器并没有效果，这时候需要借助Shadowsocks 日志来确定问题的所在。<br>除了用systemctl status ss.service 查看其部分日志，还可以使用更方便的查看日志的命令组jouralctl</p><p>查看ss这个服务的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jouralctl -u ss</span><br></pre></td></tr></table></figure></p><p>如果忘记这个服务名了，查看所有日志试试看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jouralctl -xe</span><br></pre></td></tr></table></figure></p><p>如果只记得服务名中含有s这个单词，使用s查找服务名<br>列出服务状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit | grep s 或 systemctl | grep s</span><br></pre></td></tr></table></figure></p><p>列出服务开机是否启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-file --type=service | grep s</span><br></pre></td></tr></table></figure></p><p>PS.</p><ul><li><code>/usr/lib/systemd/system/</code> ：软件包安装的单元<br>– 注解: Ubuntu 还有 <code>/lib/systemd/system/</code></li><li><code>/etc/systemd/system/</code>：系统管理员安装的单元，开机启动的单元目录  </li></ul><p>开机时间小助手<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze blame #查看各个服务的开机启动时间</span><br><span class="line">systemd-analyze plot &gt; boot.svg #导出开机时间图</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文以 Shadowsocks 为例，如何使用 Systemd 为 Shadowsocks 添加开机启动，&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.zengyilun.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.zengyilun.com/tags/linux/"/>
    
      <category term="systemd" scheme="http://www.zengyilun.com/tags/systemd/"/>
    
      <category term="shadowsocks" scheme="http://www.zengyilun.com/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议深究</title>
    <link href="http://www.zengyilun.com/http/"/>
    <id>http://www.zengyilun.com/http/</id>
    <published>2017-05-22T07:27:16.000Z</published>
    <updated>2018-10-12T01:19:04.378Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 协议深究。</p><a id="more"></a><h1 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h1><p>因特网上有数千种不同的数据类型，HTTP都要给每种传输对象打上名为MIME类型，MIME 类型原为电子邮件中使用。全称是 <code>Multipurpose Internet Mail Extension</code>。</p><p>Header 中的 <code>Content-Type</code> 就是MIME类型。</p><p>MIME类型由一个主类型和子类型构成，中间加一条斜杠。以下是常见的一些MIME类型：</p><ul><li>HTML 由 text/html 标记</li><li>普通的ASCII文档 用 text/plain</li><li>JPEG 使用 image/jpeg</li><li>gif 使用 image/gif</li><li>powerPoint 使用 application/vnd.ms-powerpoint</li></ul><p>常见的MIME类型由数百个。</p><h1 id="资源访问"><a href="#资源访问" class="headerlink" title="资源访问"></a>资源访问</h1><ul><li>URI 统一资源标识符</li><li>URL 统一资源定位符 url = schema + host + resource_url</li><li>URN 统一资源名称(比如 urn:ietf:rfc:2141)</li></ul><p>大多数URL方案的URL语法是这样子的：</p><pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?#&lt;frag&gt;</code></pre><p>为了使用安全字符集的使用限制（US-ASCII），出现编码转义%，由百分号和表示字符的ASCII码的十六进制形式，如%20代表空格(ASCII，32)。</p><h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><p>请求行与请求头是使用 CRLF 即回车换行符 <code>\r\n</code> 分割的。</p><p>请求头与请求头之间是使用 CRLF 分割的。</p><p>请求头以一个空行<code>\r\n</code>结束。</p><p>同理回应行、回应头。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>五种常见的HTTP方法。</p><ul><li>GET 获取 请求不带消息体</li><li>PUT 保存 请求带消息体</li><li>DELETE 删除 请求不带消息体</li><li>POST 提交 请求带消息体</li><li>HEAD 仅发送HTTP首部 请求不带消息体</li></ul><p>另外两种。</p><ul><li>OPTIONS 获取可用的请求方法。通过回复头 Allow 回复。请求不带消息体</li><li>TRACE 跟踪代理。通过回复头 Via 回复。请求不带消息体。</li></ul><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>常见的HTTP状态码。</p><ul><li>200 OK</li><li>302 Redirect</li><li>404 Not Found</li><li>500 Internal Server Error</li></ul><h2 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h2><p>通过客户端的请求头 Expect: 100 Continue 说明客户端将后续发送请求体， 当客户端收到服务端返回的100状态码，然后才将实体发送给服务端，当然，客户端如果到了超时时间却没有收到服务端的100状态码，也会继续发送。</p><h1 id="报文-1"><a href="#报文-1" class="headerlink" title="报文"></a>报文</h1><p>HTTP报文都是纯文本，不是二进制代码。报文包含：起始行、首部、主体。</p><p>首部以<strong>一个空行</strong>结束。</p><p>Content-Length 说明了<strong>响应主体</strong>的长度。</p><h1 id="Web-结构组件"><a href="#Web-结构组件" class="headerlink" title="Web 结构组件"></a>Web 结构组件</h1><ul><li>代理 </li><li>代理缓存</li><li>网关 将HTTP流量转换成其他的协议。比如http-&gt;ftp</li><li>隧道 对数据进行盲转发</li><li>Agent 代理</li></ul><p>未完待续…</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《HTTP 权威指南》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 协议深究。&lt;/p&gt;
    
    </summary>
    
    
      <category term="network" scheme="http://www.zengyilun.com/tags/network/"/>
    
      <category term="http" scheme="http://www.zengyilun.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft 制造计算机（二） - 半加器</title>
    <link href="http://www.zengyilun.com/logic-gate-and-mc-2/"/>
    <id>http://www.zengyilun.com/logic-gate-and-mc-2/</id>
    <published>2017-05-22T05:50:14.000Z</published>
    <updated>2018-10-12T01:19:04.378Z</updated>
    
    <content type="html"><![CDATA[<p>通过逻辑门来造加法器辣。</p><a id="more"></a><h1 id="制表"><a href="#制表" class="headerlink" title="制表"></a>制表</h1><p>有了上一篇 <a href="/logic-gate-and-mc-1/" title="Minecraft 制造计算机（一） - 逻辑门">Minecraft 制造计算机（一） - 逻辑门</a> 的基础，下面介绍如何使用逻辑门造一个半加器。</p><p>先来看一看二进制的加法:</p><pre><code>1 + 0 = 10 + 1 = 10 + 0 = 01 + 1 = 10</code></pre><p>这就是二进制加法表，如果将二进制加法的值拆分为进位、和，其对应的表格如下:</p><p>进位表(与)：</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p><img src="/images/mc/NANDgate.png" alt=""></p><p>和表(异或):</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/XORgate.png" alt=""></p><h1 id="制造"><a href="#制造" class="headerlink" title="制造"></a>制造</h1><p>可以看到，进位表就是一个逻辑与、而和表就是一个逻辑异或。有了基础理论，半加器做起来也很容易了：</p><p><img src="/images/mc/09.jpg" alt=""></p><p><img src="/images/mc/10.gif" alt=""></p><p>开关的向上代表0，向下代表1，灯泡的亮表示1暗表示0，正好符合加法表：</p><pre><code>0 0 得 01 0 得 10 1 得 11 1 得 10</code></pre><p>做出了半加器，下一篇  将描述如何制作全加器</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过逻辑门来造加法器辣。&lt;/p&gt;
    
    </summary>
    
      <category term="minecraft 造计算机系列" scheme="http://www.zengyilun.com/categories/minecraft-%E9%80%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="logic-gates" scheme="http://www.zengyilun.com/tags/logic-gates/"/>
    
      <category term="minecraft" scheme="http://www.zengyilun.com/tags/minecraft/"/>
    
  </entry>
  
  <entry>
    <title>Spark 计算文章相似度</title>
    <link href="http://www.zengyilun.com/spark-similarity/"/>
    <id>http://www.zengyilun.com/spark-similarity/</id>
    <published>2017-05-18T06:17:01.000Z</published>
    <updated>2018-10-12T01:19:04.377Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用 Spark 并行计算文章与文章之间的相似度？</p><a id="more"></a><h1 id="计算TF-IDF"><a href="#计算TF-IDF" class="headerlink" title="计算TF-IDF"></a>计算TF-IDF</h1><p>Term frequency-inverse document frequency（词频-逆文档频率）是一个向量化的标识，用于反应一个术语在整篇文档中的重要性。</p><p>用 t 表示一个术语(term)， d 表示文档(document)，D 表示语料库(corpus)。</p><p>( TF(t,d) ) Term Frequency 表示<strong>术语t</strong>在文档d中<strong>的个数</strong>。</p><p>( DF(t, D) ) Document Frenquency 表示在语料库中包含术语t的<strong>文档的个数</strong>。</p><p>逆文档频率是一个数字，用于测量一个术语提供了多大的信息量。</p><p>  $$ IDF(T, D) = log \frac{|D|+1}{DF(t,D)+1} $$ </p><p>也就是，</p><p>  $$ 逆文档频率 = log \frac{语料库的文档个数+1}{包含术语t的文档个数+1} $$</p><p>也就是说，包含术语t的文档个数越多，逆文档频率越小，加一是为了避免除0。TD-IDF 度量可以简单的表示为TF和IDF的乘积：</p><p>  $$ TFIDF(t, d, D) = TF(t,d)*IDF(T,D) $$</p><p>TF-IDF 表示了一个术语在文章中的重要程度，如果将一篇文章中TF-IDF组合起来，就构成了一个向量，同时，算出另外一篇文章的TF-IDF，将两篇文章的TF-IDF向量的相同词语分别对应同一个维度，再用余弦定理计算出两篇文章的余弦值，余弦值越大（最大1，向量重合），说明这两篇文章越相似。</p><p><strong>TF</strong>: 在 Spark 中，可以使用<code>HashingTF</code> 和 <code>CountVectorizer</code> 来计算TF（词频）。</p><p><strong>IDF</strong>: 在 Spark 中，使用<code>IDF</code>类来结算IDF从而计算出TF-IDF。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算tf</span></span><br><span class="line">        CountVectorizerModel countVectorizerModel = <span class="keyword">new</span> CountVectorizer().setInputCol(<span class="string">"words"</span>).setOutputCol(<span class="string">"rawFeatures"</span>).fit(wrappedWords);</span><br><span class="line">        Dataset&lt;Row&gt; featurizedData = countVectorizerModel.transform(wrappedWords);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算idf</span></span><br><span class="line">        IDF idf = <span class="keyword">new</span> IDF().setInputCol(<span class="string">"rawFeatures"</span>).setOutputCol(<span class="string">"features"</span>);</span><br><span class="line">        IDFModel idfModel = idf.fit(featurizedData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算tf-idf</span></span><br><span class="line">        Dataset&lt;Row&gt; rescaledData = idfModel.transform(featurizedData);</span><br></pre></td></tr></table></figure><h1 id="计算余弦相似度"><a href="#计算余弦相似度" class="headerlink" title="计算余弦相似度"></a>计算余弦相似度</h1><p>计算出 TF-IDF 后，将其转换为一个<code>BlockMatrix</code>矩阵。</p><pre><code>1 0 2.52078447201548 0 0 0 2.004684436494304 2.000347299268466 0 2.228387042742021 2.228387042742023 0 0 0 0 0 00 2.857738033247042 0 0 2.619965104088255 0 2.004684436494304 2.000347299268466 0 2.228387042742021 2.228387042742023 0 0 0 0 0 00 2.857738033247042 0 2.061393766919624 0 0 2.004684436494304 0 0 2.228387042742021 2.228387042742023 0 0 0 0 0 01 0 0 2.061393766919624 2.619965104088255 0 2.004684436494304 2.000347299268466 0 0 0 0 2.055002875864414 0 0 0 01 2.857738033247042 0 2.061393766919624 2.619965104088255 0 2.004684436494304 0 0 0 0 0 2.055002875864414 0 0 0 0</code></pre><p>计算出矩阵后，将其倒置。</p><p>倒置后将<code>BlockMatrix</code>转换为<code>RowMatrix</code>并使用 RowMatrix 的 columnSimilarities 这个方法将计算出每一列的余弦相似度，其结果也是一个矩阵(CoordinateMatrix)。矩阵的横坐标i代表其中某一列，纵坐标j代表另外一列，其余弦值结果就是Entry(i,j)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将稀疏向量转变为密集向量</span></span><br><span class="line">       JavaRDD&lt;Vector&gt; features = (JavaRDD&lt;Vector&gt;)rescaledData.toJavaRDD().map(<span class="keyword">new</span> Function&lt;Row, Vector&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Vector <span class="title">call</span><span class="params">(Row row)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               SparseVector features = row.getAs(<span class="string">"features"</span>);</span><br><span class="line">               <span class="keyword">return</span> Vectors.dense(features.toArray());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//构建带索引的矩阵，用于转化为分块向量</span></span><br><span class="line">       JavaRDD&lt;IndexedRow&gt; indices = (JavaRDD&lt;IndexedRow&gt;)features.zipWithIndex().map(<span class="keyword">new</span> Function&lt;Tuple2&lt;Vector, Long&gt;, IndexedRow&gt;() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> IndexedRow <span class="title">call</span><span class="params">(Tuple2&lt;Vector, Long&gt; t)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> IndexedRow(t._2(), t._1());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//得到分块矩阵的转置</span></span><br><span class="line">       BlockMatrix blockMatrix = <span class="keyword">new</span> IndexedRowMatrix(indices.rdd()).toBlockMatrix().transpose();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//得到行矩阵</span></span><br><span class="line">       RowMatrix rowMatrix = blockMatrix.toCoordinateMatrix().toRowMatrix();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计算行矩阵的列相似度，获得带坐标的相似度矩阵（结果输出）</span></span><br><span class="line">       CoordinateMatrix res = rowMatrix.columnSimilarities();</span><br></pre></td></tr></table></figure><p>计算出余弦值结果后再将通过文章id和i、j的映射取出对应的文章id，文章与文章的相似度也就能保存在数据库中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将相似度矩阵转换，并存储数据库。</span></span><br><span class="line">       JavaRDD&lt;Document&gt; documents = (JavaRDD&lt;Document&gt;)res.entries().toJavaRDD().map(<span class="keyword">new</span> Function&lt;MatrixEntry, Document&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Document <span class="title">call</span><span class="params">(MatrixEntry entry)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               Document d = <span class="keyword">new</span> Document();</span><br><span class="line">               d.put(<span class="string">"id1"</span>, ids.get(<span class="keyword">new</span> Long(entry.i()).intValue()));</span><br><span class="line">               d.put(<span class="string">"id2"</span>, ids.get(<span class="keyword">new</span> Long(entry.j()).intValue()));</span><br><span class="line">               d.put(<span class="string">"score"</span>, entry.value());</span><br><span class="line">               <span class="keyword">return</span> d;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><a href="https://databricks.com/blog/2014/10/20/efficient-similarity-algorithm-now-in-spark-twitter.html" target="_blank" rel="noopener">感谢 databricks 的文章</a></p><p>columnSimilarites 计算余弦相似度采用TWITTER的 DIMSUM 算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何使用 Spark 并行计算文章与文章之间的相似度？&lt;/p&gt;
    
    </summary>
    
    
      <category term="spark" scheme="http://www.zengyilun.com/tags/spark/"/>
    
      <category term="machine learning" scheme="http://www.zengyilun.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft 制造计算机（一） - 逻辑门</title>
    <link href="http://www.zengyilun.com/logic-gate-and-mc-1/"/>
    <id>http://www.zengyilun.com/logic-gate-and-mc-1/</id>
    <published>2017-05-16T00:24:14.000Z</published>
    <updated>2018-10-12T01:19:04.377Z</updated>
    
    <content type="html"><![CDATA[<p>如何在 Minecraft 中制造逻辑门？</p><a id="more"></a><h2 id="现实世界中的逻辑门"><a href="#现实世界中的逻辑门" class="headerlink" title="现实世界中的逻辑门"></a>现实世界中的逻辑门</h2><p>上一篇 <a href="/bool">布尔代数与计算机</a> 中介绍了如何使用电路来表示布尔逻辑运算，使用<br>串联来表示与运算（交集），使用并联来表示或运算（并集），其实它们都有一个专门的名字：与门、或门。</p><p>与门：<br><img src="/images/bool/01.png" alt=""></p><p>或门：<br><img src="/images/bool/02.png" alt=""></p><p>当输入为0，输出为其取反即0时，这种逻辑电路称为反向器。</p><h2 id="Minecraft-红石电路基本元件"><a href="#Minecraft-红石电路基本元件" class="headerlink" title="Minecraft 红石电路基本元件"></a>Minecraft 红石电路基本元件</h2><p>因此，通过串联，并联，并通过电路是否通电来表示数学中的逻辑运算。Minecraft 中红石电路可以实现基本的逻辑门，从而可以制造出加法器、减法器、锁存器等等。</p><p>Minecraft 中关于红石电路和逻辑门的信息（只讨论使用基本的红石电路，不包括光敏传感器等）；</p><ul><li>红石电源有好几种：拉杆（开关）、红石火把</li><li>开关常用于逻辑门，因为他们易于制作和使用</li><li>当红石火把有供电，他们反而会熄灭，并停止提供电源(<strong>重要！</strong>)</li></ul><h2 id="关键图"><a href="#关键图" class="headerlink" title="关键图"></a>关键图</h2><p><img src="/images/mc/MCGatesKey.png" alt=""><br>从左至右：</p><ol><li>空气（空）</li><li>开关（电源）</li><li>方块（通用）</li><li>红石火把（方块侧）</li><li>红石火把（地上）</li><li>红石火把（方块上）</li><li>红石（地上）</li><li>红石（方块上）</li><li>红石（输出）</li></ol><h2 id="逻辑门的制作"><a href="#逻辑门的制作" class="headerlink" title="逻辑门的制作"></a>逻辑门的制作</h2><h2 id="反向器"><a href="#反向器" class="headerlink" title="反向器"></a>反向器</h2><p>是一个电源与输出状态相反的逻辑元件。当电源开着，则输出会关掉，反之亦然。</p><table><thead><tr><th>电源</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/NOTgate.png" alt=""></p><p>游戏中实际表示为：</p><p><img src="/images/mc/01.png" alt=""></p><h2 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h2><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><p><img src="/images/mc/ORgate.png" alt=""></p><p>游戏中实际表示为：</p><p><img src="/images/mc/02.png" alt=""></p><h2 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h2><p>与门稍微复杂些，这与MC中开关即电源有关系。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p><strong>错误的表示方法</strong>， 因为开关就是一个电源！ 这样的话只要开启后一个开关灯就会亮了：</p><p><img src="/images/mc/03.png" alt=""></p><p><strong>正确的表示方法</strong>:</p><p><img src="/images/mc/ANDgate.png" alt=""></p><p><img src="/images/mc/08.png" alt=""></p><p>既然不能直接构造与门，这里使用了2个反向器与一个或门再加一个反向器，根据德·摩根定律：</p><p>$$ A \land B = \neg ( \neg (A \land B)) = \neg ( \neg A \lor \neg B) $$ </p><p>即与门可以用反向器和或门表示。</p><h2 id="或非门"><a href="#或非门" class="headerlink" title="或非门"></a>或非门</h2><p>或非门即或门取反。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/NORgate.png" alt=""></p><p><img src="/images/mc/06.png" alt=""></p><h2 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h2><p>与非门即与门取反。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/NANDgate.png" alt=""></p><p><img src="/images/mc/07.png" alt=""></p><h2 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h2><p>相同即为0，不同即为1。异或门由 或门、与非门、与门构成，或门与与非门的输出作为与门的输入。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/04.png" alt=""></p><p><img src="/images/mc/XORgate.png" alt=""></p><h2 id="同或门"><a href="#同或门" class="headerlink" title="同或门"></a>同或门</h2><p>相同即为1，不同即为0，即异或门取反。只需要在异或门后面取反就行了。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p><img src="/images/mc/XNORgate.png" alt=""></p><p>下面将使用这些逻辑门做一个半加器 <a href="/logic-gate-and-mc-2/" title="Minecraft 制造计算机（二） - 半加器">Minecraft 制造计算机（二） - 半加器</a> 吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在 Minecraft 中制造逻辑门？&lt;/p&gt;
    
    </summary>
    
      <category term="minecraft 造计算机系列" scheme="http://www.zengyilun.com/categories/minecraft-%E9%80%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="logic-gates" scheme="http://www.zengyilun.com/tags/logic-gates/"/>
    
      <category term="minecraft" scheme="http://www.zengyilun.com/tags/minecraft/"/>
    
  </entry>
  
  <entry>
    <title>Spark 快速入门教程（三） - 搭建集群</title>
    <link href="http://www.zengyilun.com/spark-3/"/>
    <id>http://www.zengyilun.com/spark-3/</id>
    <published>2017-05-10T07:55:01.000Z</published>
    <updated>2018-10-12T01:19:04.377Z</updated>
    
    <content type="html"><![CDATA[<p>如何搭建Spark集群？</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>搭建集群前需要了解 Spark 集群的一些术语：</p><ul><li>Driver 驱动器，也就是程序入口，带main函数的那个程序。</li><li>Master 主节点，并不会参与预算，只是用作管理集群。不要和Driver混淆，Master≠Driver。节点都是指<strong>机器</strong>，Driver是指带main函数的<strong>程序</strong>。Driver可以运行在Master上，也可以运行在Worker上，还可以运行在这两者之外的远程机器上。</li><li>Worker 计算节点，Spark RDD运算时就是在计算节点上执行的。</li><li>Executor 执行器，这个是运行在 Worker 上的真正的执行程序，这是一个<strong>进程</strong>，是由 Worker 上的 spark 开启并管理的，也就是说在 Worker 的 spark 程序开启远程调试，由调试客户端进行调试时，并不能成功的调试 Executor 完成 Jobs 的过程。</li></ul><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>在主节点 Master 上添加 Worker 很简单，在根目录 <code>/conf/slaves</code> 配置文件添加 Worker节点 ip 或 主机名（主机名可用ssh配置）即可，也可以把自己也添加进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost</span><br><span class="line">192.168.2.230</span><br></pre></td></tr></table></figure><p>启动<code>/sbin/start-all</code>，集群开始运行，报错…无法连接到目标主机。</p><p>当然，直接启动另外一台电脑上的程序肯定不会成功，要能成功连接到 Worker，需要配置 ssh ，必须让 Master 能无密码连接到 Worker 才能启动 Worker 节点的 Spark。</p><ol><li>Worker <code>ssh-keygen -t rsa</code> 生成秘钥，并添加 authorized_keys, <code>cat id_rsa &gt; authorized_keys</code></li><li>将 Worker 的秘钥发送到 Master <code>scp ~/.ssh/id_rsa root@master:/.ssh/</code> </li><li>配置 ssh_config</li></ol><p>连接测试 ssh 到 Worker 后，<code>/sbin/start-all</code> 成功。</p><h1 id="关于启动-Worker-的两个脚本"><a href="#关于启动-Worker-的两个脚本" class="headerlink" title="关于启动 Worker 的两个脚本"></a>关于启动 Worker 的两个脚本</h1><p><code>/sbin/</code> 下有两个脚本 <code>start-slaves.sh</code> 和 <code>start-slave.sh</code>，他们的区别是前者启动本Master管理的所有 Worker节点（启动别人），而<code>start-slave.sh</code>需要指定一个Master，当本机作为Worker 节点并且挂了的时候，需要重新连接到Master时使用。</p><h1 id="部署模式-deploy-mode-Cluster-与-Client"><a href="#部署模式-deploy-mode-Cluster-与-Client" class="headerlink" title="部署模式(deploy mode) Cluster 与 Client"></a>部署模式(deploy mode) Cluster 与 Client</h1><p>部署模式决定了Driver是在本地运行还是在集群上运行，Client是本地运行，而Cluster是在集群上的某一个 Worker上运行，默认是Client。通过指定spark-submit的参数–deploy-mode来指定，注意，如果是cluster模式，刚好选中的Worker必须要有驱动器程序，而且工作路径 和 提交driver时所在机器的所在路径一致, 也就是说，如果你在windows上提交driver，使用 Cluster 模式， 而选中的 Worker 是 linux系统，这是肯定不能执行成功的，因为在linux执行 driver 时，使用的是windows系统的盘符。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何搭建Spark集群？&lt;/p&gt;
    
    </summary>
    
      <category term="spark 入门系列" scheme="http://www.zengyilun.com/categories/spark-%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="spark" scheme="http://www.zengyilun.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>布尔代数与计算机</title>
    <link href="http://www.zengyilun.com/bool/"/>
    <id>http://www.zengyilun.com/bool/</id>
    <published>2017-05-09T05:21:47.000Z</published>
    <updated>2018-10-12T01:19:04.377Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用布尔代数制造一个计算机？</p><a id="more"></a><p>在古希腊时期，有一段著名的亚里士多德三段论：</p><blockquote><p>人总是要死的。<br>  苏格拉底是人。<br>  所以，苏格拉底是要死的。</p></blockquote><p>三句话虽然看起来很直白，但是却无法用数学证明，人们总是用代数来代表数字，无法用数学表示逻辑。</p><p>直到 乔治·布尔 ——</p><p><img src="/images/bool/04.png" alt=""></p><p>他提出了一个与常规代数相似而又不相同的代数——布尔代数。其与常规代数最大的不同就是，常规代数表示的是数字，而布尔代数表示的是集（类），使代数更加抽象。</p><p>他将集的操作分为两类：</p><p>＋：两个集合的并集<br>×：两个集合的交集</p><p>其运算符合以下性质，使用 0 代表空集，使用 1 代表全集，使用 (1 － A) 代表A的补集：</p><p>交换律：A ＋ B = B ＋ A<br>结合律：(A ＋ B) ＋ C = A + (B + C)<br>    (A × B) × C = A × (B × C)<br>分配律：(A ＋ B) × C = A × C + B × C<br>    (A × B) ＋ C = (A ＋ C) × (B ＋ C)<br>全集与空集：A ＋ 0 = A<br>        A ＋ 1 = A<br>补集：    A ＋ (1 － A) = 1<br>        A × (1 － A) = 0<br>德·摩根定律：1 － (A＋B) = (1 － A) × (1 － B)<br>          1 － (A×B) = (1 － A) ＋ (1 － B)</p><p>这是最初布尔用的＋×符号，后来人们为了与传统代数运算区分开，亦可使用∪、∩、ˉ代表集合的并、交、补。</p><p>注意，和传统代数有区别的是 <code>(A × B) ＋ C = (A ＋ C) × (B ＋ C)</code> 这在传统代数中是不成立的。</p><p>于是，将人用P表示，要死的东西用M表示，苏格拉底用S表示。<br>由第一句话，人总是要死的可以推出：</p><pre><code>P × M = P</code></pre><p>为什么不是 P × M = M 呢， 因为要死的东西不只是人，还有其他动物植物。<br>由第二句话， 苏格拉底是人可以推出：</p><pre><code>S × P = S</code></pre><p>为什么不是 S × P = P ，因为不只是只有苏格拉底一个人。<br>将第一个式子 P × M = P 带入第二个式子：</p><pre><code>S × (P × M) = S</code></pre><p>根据结合律：</p><pre><code>(S × P) × M = S</code></pre><p>由于第二个式子 S × P = S ，所以</p><pre><code>S × M = S</code></pre><p>由此推断，苏格拉底和要死的东西取交集就是苏格拉底，推出第三个句话的结论：苏格拉底会死。如果 S × M = 0 说明，苏格拉底会永生，如果 S × M = M，说明只有苏格拉底要死，其他生物都不会死。</p><p>布尔代数除了能集合运算，还能进行逻辑运算，逻辑运算使用 AND、OR、NOT分别代表集合中的 交集、并集、补集。用逻辑运算的符号表示是 ∨、∧、「。</p><p>如果能只用2种状态来表示集合，就出现了逻辑演算。用 1 代表真(全集)、 0 代表假(空集)，就会出现以下的表格：</p><table><thead><tr><th style="text-align:center">∨</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><table><thead><tr><th style="text-align:center">∧</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p>假设要买一只猫，跟店员说“我想要一只绝育的公猫，白色或黄褐色的，或者一只除了白色的绝育母猫，再或者只要是黑猫就行”。</p><p>用 M 代表公猫、F 代表母猫。白色 W、黄褐色 T、黑色 B、其他颜色 O 。N 绝育、U 没有绝育。</p><p>所以用集合来表示这个逻辑为：</p><pre><code>(M × N × (W ＋ T)) ＋ (F × N × (1 一 W)) + B</code></pre><p>接下来店员将一只猫做布尔测试，看看到底这只猫符不符合我的要求，发现用集合表示并不方便。于是使用逻辑来表示：</p><pre><code>(M AND N AND (W OR T)) OR (F AND N AND NOT W)) OR B</code></pre><p>当店员拿来一直白色未绝育公猫，用 1 代表 YES, 0 代表 NO，代入上面的逻辑表达式。</p><pre><code>(1 AND 0 AND (1 OR 0 )) OR (0 AND 0 AND NOT 1)) OR 0(1 * 0 * (1 + 0)) + (0 * 0 * (1 - 1)) + 0 = 0</code></pre><p>所以这只猫并不符合。</p><p>店员每次手动测试猫是不是符合要求，为什么不适用电路来代替手工运算呢。</p><p>电路串联：</p><p><img src="/images/bool/01.png" alt=""></p><p>两个开关，1代表闭合，0代表断开，当且仅当两个开关为闭合的时候，灯才会亮。这与逻辑与是一致的。</p><p><img src="/images/bool/02.png" alt=""></p><p>电路并联：<br>仅有一个开关为闭合，或者两个开关都闭合，灯就会亮。这与逻辑或是一致的。</p><p>于是店员将测试猫的表达式转换成了电路，使用电路来测试猫是否符合要求。</p><p><img src="/images/bool/03.png" alt=""> </p><p>通过操作开关的闭合，根据灯泡的亮与不亮就能判断出这只猫是不是符合要求。</p><p>附录：</p><p>代码中的布尔运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> a = Math.random() &gt; <span class="number">0.5</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = Math.random() &gt; <span class="number">0.5</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> c = Math.random() &gt; <span class="number">0.5</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        compare(a || b, b || a); <span class="comment">//交换律</span></span><br><span class="line">        compare(a || (b || c), (a || b) || c); <span class="comment">//加法结合律</span></span><br><span class="line">        compare(a &amp;&amp; (b &amp;&amp; c), (a &amp;&amp; b) &amp;&amp; c); <span class="comment">//乘法结合律</span></span><br><span class="line">        compare(a &amp;&amp; (b || c), a &amp;&amp; b || a &amp;&amp; c); <span class="comment">//分配律</span></span><br><span class="line">        compare(a || (b &amp;&amp; c), (a || b) &amp;&amp; (a || c)); <span class="comment">//分配律</span></span><br><span class="line">        compare(!(a &amp;&amp; b), !a || !b); <span class="comment">//德·摩根定律</span></span><br><span class="line">        compare(!(a || b ), !a &amp;&amp; !b);<span class="comment">//德·摩根定律</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">boolean</span> left, <span class="keyword">boolean</span> right)</span></span>&#123;</span><br><span class="line">        System.out.println(left == right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用0和1代替布尔值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> a = (<span class="keyword">byte</span>) (Math.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) (Math.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">byte</span> c = (<span class="keyword">byte</span>) (Math.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        compare(a | b, b | a);<span class="comment">//交换律</span></span><br><span class="line">        compare((a | b) | c, a | (b | c));<span class="comment">//加法结合律</span></span><br><span class="line">        compare((a &amp; b) &amp; c, a &amp; (b &amp; c));<span class="comment">//乘法结合律</span></span><br><span class="line">        compare(a &amp; (b | c), a &amp; b | a &amp; c);<span class="comment">//分配律</span></span><br><span class="line">        compare(a | (b &amp; c), (a | b) &amp; (a | c));<span class="comment">//分配律</span></span><br><span class="line">        compare(~(a &amp; b), ~a | ~b);<span class="comment">//德·摩根定律</span></span><br><span class="line">        compare(~(a | b ), ~a &amp; ~b);<span class="comment">//德·摩根定律</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        System.out.println(left == right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何使用布尔代数制造一个计算机？&lt;/p&gt;
    
    </summary>
    
    
      <category term="math" scheme="http://www.zengyilun.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Spark 远程调试</title>
    <link href="http://www.zengyilun.com/spark-debug/"/>
    <id>http://www.zengyilun.com/spark-debug/</id>
    <published>2017-05-09T04:00:00.000Z</published>
    <updated>2018-10-12T01:19:04.377Z</updated>
    
    <content type="html"><![CDATA[<p>使用 java remote debug 功能， 借助intellij idea 远程调试 WordCount 程序。</p><a id="more"></a><p>Java 中进行远程调试步骤：</p><ol><li>在服务端配置启动参数，激活服务端的远程调试功能。</li><li>本地客户端连接调试服务端。</li><li>添加断点并且启动本地程序。</li></ol><p>配置 Master 远程调试： 配置 Spark java 运行参数。</p><p>找到 <code>SPARK_HOME/conf/spark-env.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPARK_MASTER_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure><p>修改后， 启动 Spark 集群 <code>SPARK_HOME/sbin/start-all.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep java | grep master</span><br><span class="line">root     21610     1  6 02:58 pts/0    00:00:05 /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.131-2.b11.el7_3.x86_64/jre/bin/java -cp /usr/<span class="built_in">local</span>/spark-2.1.0-bin-hadoop2.7/conf/:/usr/<span class="built_in">local</span>/spark-2.1.0-bin-hadoop2.7/jars/* -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5005 -Xmx1g org.apache.spark.deploy.master.Master --host 192.168.2.5 --port 7077 --webui-port 8080</span><br></pre></td></tr></table></figure><p>可以看到 java 运行参数已经被加上了。</p><p>添加 Spark Master 程序断点 <code>Master.scala</code></p><p><img src="/images/spark/spark-04.png" alt=""></p><p>点击调试按钮，连接调试服务端</p><p><img src="/images/spark/spark-02.png" alt=""></p><p><img src="/images/spark/spark-10.png" alt=""></p><p>启动本地驱动程序，Master 程序已经调试成功了</p><p><img src="/images/spark/spark-09.png" alt=""></p><p><img src="/images/spark/spark-08.png" alt=""></p><p>接下来，配置 Worker 远程调试。</p><p>同理配置 <code>SPARK_HOME/conf/spark-env.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPARK_WORKER_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure><p>在 Worker.scala 打上断点</p><p><img src="/images/spark/spark-11.png" alt=""></p><p>客户端连接服务端</p><p><img src="/images/spark/spark-07.png" alt=""></p><p><img src="/images/spark/spark-06.png" alt=""></p><p>执行本地驱动程序，Worker 程序调试成功</p><p><img src="/images/spark/spark-09.png" alt=""></p><p><img src="/images/spark/spark-05.png" alt=""></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight java"><figcaption><span>WordCount.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"wordCount"</span>)</span><br><span class="line">                .setJars(<span class="keyword">new</span> String[]&#123;<span class="string">".//target//wordcount.jar"</span>&#125;)</span><br><span class="line">                .setMaster(<span class="string">"spark://192.168.2.5:7077"</span>);</span><br><span class="line">        JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line">        JavaRDD&lt;String&gt; input = sc.textFile(<span class="string">"/usr/local/spark-2.1.0-bin-hadoop2.7/README.md"</span>);</span><br><span class="line">        JavaRDD&lt;String&gt; words = input.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.asList(s.split(<span class="string">" "</span>)).iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JavaPairRDD&lt;Object, Object&gt; counts = words.mapToPair(<span class="keyword">new</span> PairFunction&lt;String, Object, Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;Object, Object&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;Object, Object&gt;(s, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).reduceByKey(<span class="keyword">new</span> Function2&lt;Object, Object, Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Object x, Object y)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Integer)x + (Integer)y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        counts.saveAsTextFile(<span class="string">"/tmp/wc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 java remote debug 功能， 借助intellij idea 远程调试 WordCount 程序。&lt;/p&gt;
    
    </summary>
    
      <category term="spark 入门系列" scheme="http://www.zengyilun.com/categories/spark-%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="spark" scheme="http://www.zengyilun.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark 快速入门教程（二） - Self-Contained 应用程序</title>
    <link href="http://www.zengyilun.com/spark-2/"/>
    <id>http://www.zengyilun.com/spark-2/</id>
    <published>2017-05-09T02:47:12.000Z</published>
    <updated>2018-10-12T01:19:04.377Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用独立应用程序(self-contained applications) 来使用Spark API， 实现一个单词计数小程序。</p><a id="more"></a><p>新建一个Maven项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate</span><br></pre></td></tr></table></figure><p>编辑MAVEN配置文件</p><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zengyilun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spark Hello Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- Spark dependency --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建驱动程序（含主函数的程序） 来实现单词技术的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"wordCount"</span>);</span><br><span class="line">        JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"plz input args[0](input-path) args[1](output-path)"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        JavaRDD&lt;String&gt; input = sc.textFile(args[<span class="number">0</span>]);</span><br><span class="line">        JavaRDD&lt;String&gt; words = input.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.asList(s.split(<span class="string">" "</span>)).iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JavaPairRDD&lt;Object, Object&gt; counts = words.mapToPair(<span class="keyword">new</span> PairFunction&lt;String, Object, Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;Object, Object&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;Object, Object&gt;(s, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).reduceByKey(<span class="keyword">new</span> Function2&lt;Object, Object, Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Object x, Object y)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Integer)x + (Integer)y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        counts.saveAsTextFile(args[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前的项目结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find .</span><br><span class="line">./pom.xml</span><br><span class="line">./src</span><br><span class="line">./src/main</span><br><span class="line">./src/main/java</span><br><span class="line">./src/main/java/WordCount.java</span><br></pre></td></tr></table></figure><p>构建项目， 使用 <code>./bin/spark-submit</code> 提交并执行项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mvn package</span><br><span class="line"></span><br><span class="line">[INFO] Building jar : &#123;..&#125;/&#123;..&#125;/target/spark-hello.jar</span><br><span class="line"></span><br><span class="line">$ SPARK_HOME/bin/spark-submit --class <span class="string">"WordCount"</span> target/spark-hello.jar SPARK_HOME/README.md /tmp/wc</span><br></pre></td></tr></table></figure><p>通过传入 Spark 目录下的README.md， Spark 统计单词结构将会输出在 /tmp/wc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ find /tmp/wc</span><br><span class="line">part-00000</span><br><span class="line">part-00001</span><br><span class="line">_SUCCESS</span><br><span class="line">$ cat /tmp/wc/_part-00000</span><br><span class="line">(package,1)</span><br><span class="line">(this,1)</span><br><span class="line">(Version<span class="string">"](http://spark.apache.org/docs/latest/building-spark.html#specifying-the-hadoop-version),1)</span></span><br><span class="line"><span class="string">(Because,1)</span></span><br><span class="line"><span class="string">(Python,2)</span></span><br><span class="line"><span class="string">(page](http://spark.apache.org/documentation.html).,1)</span></span><br><span class="line"><span class="string">(cluster.,1)</span></span><br><span class="line"><span class="string">(its,1)</span></span><br><span class="line"><span class="string">([run,1)</span></span><br><span class="line"><span class="string">(general,3)</span></span><br><span class="line"><span class="string">(have,1)</span></span><br><span class="line"><span class="string">(pre-built,1)</span></span><br><span class="line"><span class="string">(YARN,,1)</span></span><br><span class="line"><span class="string">([http://spark.apache.org/developer-tools.html](the,1)</span></span><br><span class="line"><span class="string">(changed,1)</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Spark 快速大数据分析》</li><li>[Spark 官方文档](<a href="http://spark.apache.org/docs/latest/" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何使用独立应用程序(self-contained applications) 来使用Spark API， 实现一个单词计数小程序。&lt;/p&gt;
    
    </summary>
    
      <category term="spark 入门系列" scheme="http://www.zengyilun.com/categories/spark-%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="spark" scheme="http://www.zengyilun.com/tags/spark/"/>
    
  </entry>
  
</feed>
