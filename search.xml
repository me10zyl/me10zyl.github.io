<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>20190506105402</title>
      <link href="/nginx/"/>
      <url>/nginx/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>MIUI_QQ耗电毒瘤关闭没用的功能节约电量</title>
      <link href="/Hexo1/"/>
      <url>/Hexo1/</url>
      
        <content type="html"><![CDATA[<p>手机QQ耗电毒瘤，关闭没用的功能节省电量</p><a id="more"></a><p><img src="/images/Hexo1/20181106094846183.png" alt=""></p><ol><li><p>关闭所有没用的动态</p><p>  动态-&gt;右上角点更多-&gt;关闭没用的动态<br>  特别是运动要关闭，计步是非常耗电的</p></li><li><p>把所有不需要的接受消息的群全部屏蔽</p></li><li>MIUI 安全中心-&gt;电量-&gt;QQ智能省电</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> QQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows/Mac下黑苹果简易安装步骤【Intel HD Graphics 630】</title>
      <link href="/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
      <url>/%E9%BB%91%E8%8B%B9%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="http://bbs.pcbeta.com/" target="_blank" rel="noopener">http://bbs.pcbeta.com/</a> 远景论坛</li><li><a href="https://imac.hk/" target="_blank" rel="noopener">https://imac.hk/</a> 黑苹果乐园</li><li><a href="https://www.tonymacx86.com/" target="_blank" rel="noopener">https://www.tonymacx86.com/</a> tonymacx86</li></ul><a id="more"></a><h2 id="Windows-下安装黑苹果"><a href="#Windows-下安装黑苹果" class="headerlink" title="Windows 下安装黑苹果:"></a>Windows 下安装黑苹果:</h2><p>硬件材料准备：两个大于8G的U盘。【若是VGA显示器，需配备PCI/24 转 VGA 转接头（因为是核显，Mac不再支持核显VGA，若是独显则不需要）】</p><ol><li>首先下载 Mac with Clover</li><li>使用TransMac 将镜像拷贝进U盘</li><li>制作WinPE的U盘，插入U盘，重启。进入WindowsPE系统，将要安装MAC的磁盘，MBR转换为GUID分区。</li><li>预留一个300MB的ESP分区，并且格式化一个HFS+的80G硬盘给苹果安装系统。</li><li>重启，进入CloverU盘，磁盘工具，格式化HFS+的80G硬盘为苹果日志式硬盘。</li><li>开始安装苹果，等待安装。</li><li>再此进入WinPE的U盘，将CloverU盘的EFI文件夹拷贝到硬盘的ESP分区，以便脱离U盘可以使用硬盘驱动。重启。</li><li>使用F11 BootMenu进入Clover引导，运行Mac，开始正式安装Mac，等待安装完成。</li><li>进入苹果系统，发现浏览器有花屏，下载Nvida WebDriver显卡驱动，重启。</li><li>再次进入苹果系统，无限循环，无法进入系统，重启，进入WinPEU盘。</li><li>更改ESP的Clover的plist配置，找到并配置<code>&lt;key&gt;Arguments&lt;key&gt; &lt;string&gt;nvda_drv=1 kext-dev-mode=1&lt;/string&gt;</code>，重启进入MAC。</li><li>能再次进入苹果，并且浏览器无花屏，安装完成！</li></ol><h2 id="Mac-下重装黑苹果"><a href="#Mac-下重装黑苹果" class="headerlink" title="Mac 下重装黑苹果"></a>Mac 下重装黑苹果</h2><p>此步骤用于已经安装了黑苹果，想重装系统的方式</p><h4 id="一、安装系统"><a href="#一、安装系统" class="headerlink" title="一、安装系统"></a>一、安装系统</h4><p>无论白苹果、黑苹果，首先需要下载一个新系统，在应用商店搜索 OS X，你就会看到目前最新系统，点 download 下载。</p><h4 id="二、制作U盘"><a href="#二、制作U盘" class="headerlink" title="二、制作U盘"></a>二、制作U盘</h4><p>官方教程： <a href="https://support.apple.com/en-us/HT201372" target="_blank" rel="noopener">https://support.apple.com/en-us/HT201372</a></p><ol><li><p>第一步格式化 U 盘，调出spotlight (Ctrl + Space)，搜索 disk utility，找到自己的 U 盘，格式化为 GUID ，janary 格式，名称可以默认Untitled</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath &quot;/Applications/Install OS X El Capitan.app&quot;</span><br></pre></td></tr></table></figure></li><li><p>白苹果的启动盘就制作完成了。</p></li></ol><h4 id="三、插入U盘，启动-Boot-Mac-OS-Install-From-Mac-OS-Install-重装系统"><a href="#三、插入U盘，启动-Boot-Mac-OS-Install-From-Mac-OS-Install-重装系统" class="headerlink" title="三、插入U盘，启动 Boot Mac OS Install From Mac OS Install 重装系统"></a>三、插入U盘，启动 Boot Mac OS Install From Mac OS Install 重装系统</h4>]]></content>
      
      
      
        <tags>
            
            <tag> hackintosh </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>todo</title>
      <link href="/todo/"/>
      <url>/todo/</url>
      
        <content type="html"><![CDATA[<p>现在开始看 HTTP 权威指南…《编码》暂时放一段落了。。。(MC实现进度拖延导致后面章节很难看)</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>快速写日志，Hexo的专用编辑器 - HexoEditor</title>
      <link href="/HexoEditor/"/>
      <url>/HexoEditor/</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/zhuzhuyule/HexoEditor" target="_blank" rel="noopener">https://github.com/zhuzhuyule/HexoEditor</a><br>Hexo Editor, 专门为写 Hexo日志而生， 改编自MoeEditor，支持 Markdown，Latex 等。<br><a id="more"></a><br>下载地址：<br>Windows x64: <a href="https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_win_x64.exe" target="_blank" rel="noopener">https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_win_x64.exe</a><br>Mac x64:<a href="https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_mac_x64.dmg" target="_blank" rel="noopener">https://github.com/zhuzhuyule/HexoEditor/releases/download/v1.5.30/HexoEditor_1.5.30_mac_x64.dmg</a><br><img src="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/main.png" alt="1"></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>HexoEditor 独有功能<ul><li>实时预览</li><li>支持 Hexo Tag/Filter/Renderer </li><li>支持 Hexo <code>_config.yml</code></li><li>Hexo source 中快速新建POST</li><li>快速修改文件名 (在Hexo文件中编辑)  </li><li>快速部署 Hexo</li><li>快速 Hexo 命令 <code>hexo d</code>,<code>hexo g</code>,<code>hexo s</code>,<code>hexo clean</code></li><li>在Markdown中自动添加图片<ul><li>支持图片拖拽</li><li>支持剪切板粘贴 [重点]</li></ul></li><li>支持图片上传 (一步上传)<ul><li>支持 <a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a> </li><li>支持 <a href="https://portal.qiniu.com" target="_blank" rel="noopener">QiNiu</a> </li><li>支持 <a href="https://console.cloud.tencent.com" target="_blank" rel="noopener">Tencent</a> </li></ul></li><li>快速打开 (公共目录，公共URL)</li><li>同步滚动</li></ul></li><li>HexoEditor (继承 <a href="https://github.com/Moeditor/Moeditor" target="_blank" rel="noopener">Moeditor</a>)<ul><li>GitHub 风格的 Markdown</li><li>TeX 数学表达式</li><li>UML 图</li><li>代码高亮</li><li>读/写/预览 模式</li><li>自定义字体 / 行高 / 大小</li><li>自定义主题</li><li>代码高亮主题 (powered by <a href="https://highlightjs.org/" target="_blank" rel="noopener">highlight.js</a>)</li><li>自动重加载</li><li>本地化</li><li>专注模式</li></ul></li></ul><p>Electron 构建，理论上是跨平台的，Windows Mac都能使用。<br><img src="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/menu.png" alt="https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/menu.png"></p><p>缺点：</p><ul><li>一键部署不是很好用，没有自定义添加外部程序的功能 </li><li>粘贴图片后地址为/pic.png，而不是/images/pic.png</li><li>最好有一个一键打开Hexo根目录命令行的功能</li><li>hexo 命令执行好像还没成功过，已经配了Hexo的_config.yml，无限操作执行中…如图所示：<br><img src="/images/HexoEditor/20180929093043591.png" alt="1"></li></ul><p>使用此编辑器后写博客的步骤简化为：</p><ol><li>打开 Alfred, 输入 hexo 打开 HexoEditor<br><img src="/images/HexoEditor/20180929093606497.png" alt="1"></li><li>新建 Post，在_post文件夹自动生成文件，并含有date，修改title, tag，文件名同步 title 修改。<br><img src="/images/HexoEditor/20180929093729763.png" alt="2"><br><img src="/images/HexoEditor/20180929093910225.png" alt="3"></li><li>写博客途中有图片直接截图点粘贴，自动生成图片和路径，把路径前缀加上/images<br>如 <code>![](/HexoEditor/20180929094201824.png)</code>，其中HexoEditor为标题名称，需要手动修改为<code>![](/images/HexoEditor/20180929094201824.png)</code></li><li>保存，打开终端，提交代码</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jQuery选择器练习</title>
      <link href="/jQuery%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%83%E4%B9%A0/"/>
      <url>/jQuery%E9%80%89%E6%8B%A9%E5%99%A8%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zengyilun.com/demos/html5demos/4/jqueryselectors/index.html">https://www.zengyilun.com/demos/html5demos/4/jqueryselectors/index.html</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>GitHub + Hexo + Travis 博客快速搭建指南</title>
      <link href="/hexo/"/>
      <url>/hexo/</url>
      
        <content type="html"><![CDATA[<p>1.注册一个Github账号<br>2.创建一个名为 <code>&lt;username&gt;.github.io</code> 的仓库，其中<code>&lt;username&gt;</code>为你的Github账号，这个仓库不能随便取名。这个仓库用于存储 Hexo 生成的静态HTML(master分支)。<br><a id="more"></a><br><img src="/images/hexo/20180928094051867.png" alt=""><br>3.创建一个名为 <code>blog</code> 的仓库，这个仓库也能叫其他名称，用于存储 Hexo 博客源文件。<br>4.安装 Hexo，前提是你已经安装了必备程序Nodejs</p><pre><code>npm install -g hexo-cli</code></pre><blockquote><p>注： 安装 Node.js 的最佳方式是使用 nvm。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br><span class="line">nvm install stable</span><br></pre></td></tr></table></figure></p></blockquote><p>5.找到一个文件夹 blog/，执行Hexo 博客创建命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>6.在 blog/ 中添加 <code>gulpfile.js</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line">gulp.task(<span class="string">'hexo'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">  exec(<span class="string">'hexo clean &amp;&amp; hexo g'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(err) <span class="keyword">return</span> cb(err);</span><br><span class="line">cb();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'hexo'</span>]);</span><br></pre></td></tr></table></figure></p><p>7.在 blog/ 中添加 <code>.travis.yml</code>，按需修改<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  global:</span></span><br><span class="line"><span class="attr">      - GH_PAGES_REPO:</span> <span class="string">me10zyl/me10zyl.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"node"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="bullet">-rf</span> <span class="string">node_modules/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">me10zyl</span></span><br><span class="line"><span class="attr">  email:</span> <span class="string">me10zyl@qq.com</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">pages</span></span><br><span class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  github_token:</span> <span class="string">$GH_TOKEN</span> <span class="comment"># Set in travis-ci.org dashboard</span></span><br><span class="line"><span class="attr">  target_branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  local_dir:</span> <span class="string">dist</span></span><br><span class="line"><span class="attr">  fqdn:</span> <span class="string">www.zengyilun.com</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">$GH_PAGES_REPO</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p><p>7.登陆 <a href="http://travis-ci.org" target="_blank" rel="noopener">travis-ci.org</a>，登陆你的Github账号<br>8.GitHub生成 Travis Access Token<br><img src="/images/hexo/20180928113319644.png" alt="1"></p><p><img src="/images/hexo/20180928113400040.png" alt="2"><br>9.在 Travis 仓库配置 $GH_TOKEN 环境变量，拷贝刚才生成的Access Token<br><img src="/images/hexo/20180928113446154.png" alt="3"><br>10.提交代码，等待1分钟，成功访问你的博客： <a href="http://me10zyl.github.io" target="_blank" rel="noopener">http://me10zyl.github.io</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>汇编基础</title>
      <link href="/%E6%B1%87%E7%BC%96/"/>
      <url>/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<p>一个CPU的寻址能力为8K，那么它的地址总线的宽度为 13<br>8KB = 8192 Byte = 2^13 Byte，即宽度为13<br>什么是16位CPU？<br><a id="more"></a><br>概括地讲，16位结构（16位机、字长为16，与16位结构相同）描述了一个CPU具有下面既方便的结构特性。</p><pre><code>+ 运算器一次最多可以处理16位数据+ 寄存器最大宽度为16位+ 寄存器与运算器之间的通路为16位</code></pre><p> 也就是说，能够一次性处理、传输、暂时存储的最大长度为16<br>8086CPU 的几条汇编指令</p><pre><code>mov ax,18add ax,8sub ax,8jmp 2AE3:3 # jmp 段地址：偏移地址，执行后CS=2AE3H，IP=0003Hjmp ax # 执行前，ax=1000H,CS=2000H,IP=0003H       # 执行后，ax=1000H,CS=2000H,IP=1000H       # jmp 寄存器 功能为 用寄存器中的值修改IPpush bx # 将 bx 的数据 入栈pop ax # 将栈顶的数据放入ax</code></pre><p>8086CPU 寄存器<br>    CS：CS为代码段寄存器<br>    IP：IP为指令指针寄存器<br>    假设CS中的内容为M，IP中的内容为N，8086CPU将从内存M x 16 + N 单元开始，读取一条指令并执行。<br>    DS: 通常用来存放要访问数据的段地址<br>    mov bx 1000h<br>    mov ds, bx<br>    mov al, [0]<br>    mov [0],cs<br>    上面指令将1000h(1000:0)读入al中<br>    [···]表示一个内存单元偏移地址，8086CPU的段地址取DS中的值<br>    SS 栈顶元素段地址<br>    SP 栈顶元素偏移地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jrebel破解配置</title>
      <link href="/jrebel%E7%A0%B4%E8%A7%A3%E9%85%8D%E7%BD%AE/"/>
      <url>/jrebel%E7%A0%B4%E8%A7%A3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>要破解jrebel，秩序在license server 填上反向代理idea.lanyus.com 的地址，例如配置一个nginx配置<br><a id="more"></a><br>jrebel.conf<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  jrebel.xxx.cn;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://idea.lanyus.com/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span>  /54319d1a-<span class="number">0344</span>-48a9-a70c-265ce2a887cc &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://idea.lanyus.com/;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>反代配好后，更改hosts  127.0.0.1 jrebel.xxx.cn<br>在jrebel license server 上填写<code>http://jrebel.xxx.cn/54319d1a-0344-48a9-a70c-265ce2a887cc</code> 就激活成功了，激活路径最好加上GUID，不然有可能失败</p><ul><li>激活后记得关闭jrebel的自动上传数据<br><img src="/images/2018-07-10-jrebel破解配置/20180710033210430.png" alt="aaaaaa"><br>JRebel -&gt; workoffline<br><img src="/images/2018-07-10-jrebel破解配置/20180710033244732.png" alt="aaaaaa"><br>JRebel -&gt; Advanced -&gt; Disable reporting</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> intellij idea </tag>
            
            <tag> jrebel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Intellij Idea - 理解 artifact 并与之工作</title>
      <link href="/idea-artifact/"/>
      <url>/idea-artifact/</url>
      
        <content type="html"><![CDATA[<p>Artifact - Intellij Idea 与软件工程中一个重要的概念，本文详细解释了Artifact在Intellij Idea 的存在形式与应用。</p><a id="more"></a><h2 id="什么是-artifact"><a href="#什么是-artifact" class="headerlink" title="什么是 artifact?"></a>什么是 artifact?</h2><p>Artifact 是你项目中的资源集合，用于测试、部署、发布你的软件解决方案。（例如一堆编译好的 Java 类 或者 一个打包的Java程序， 一个文件夹结构的网页应用 或者 一个打包的网页应用，等等）。  </p><p>文件夹结构的 Artifact 或者 打包的结构包括以下组件：</p><ul><li>一个或多个module的编译输出</li><li>module 依赖库 中包含的 库</li><li>资源集合 （网页、图片、描述文件等）</li><li>其他 Artifact</li><li>个别文件，目录和压缩包</li></ul><h2 id="配置-artifact"><a href="#配置-artifact" class="headerlink" title="配置 artifact"></a>配置 artifact</h2><p>通过 <code>File | Project Structure | Artifacts</code> 配置Artifact 来指定其结构和内容</p><h2 id="构建-artifacts"><a href="#构建-artifacts" class="headerlink" title="构建 artifacts"></a>构建 artifacts</h2><ol><li>通过 <code>Build | Build Artifacts</code> 构建</li><li>通过 <code>Run | Debug</code> 中的 Before  Lauch ，添加 <code>Build &lt;ArtifactName&gt; artifact</code> 任务， artifact 会在程序运行或者调试的时候 构建</li><li>artifact 构建默认输出目录为<code>out/artifacts/&lt;artifact_dir&gt;</code>，但是如果有Maven 的话输入为 <code>target/&lt;artifact_dir&gt;</code></li></ol><h2 id="构建选项"><a href="#构建选项" class="headerlink" title="构建选项"></a>构建选项</h2><p>构建一个Artifact (Build | Build Artifacts)，有如下的选项：</p><ul><li><strong>Build.</strong> 第一次使用，整个 artifact 都构建。下次使用， 只有一部分的改变会被构建 因为 最后的构建已经添加到 输出目录了。</li><li><strong>Rebuild.</strong> 整个 artifact 都构建。实际上，先使用了<code>clean</code>再使用<code>build</code></li><li><strong>Clean.</strong> 删除输出目录的所有artifact</li><li><strong>Edit.</strong> 编辑 artifact configuration</li></ul><h2 id="运行-Jar-Artifact"><a href="#运行-Jar-Artifact" class="headerlink" title="运行 Jar Artifact"></a>运行 Jar Artifact</h2><p> 通过 JAR Application run configurations 运行。</p><ol><li>打开 Run/Debug Configurations?对话框 (e.g. Run | Edit Configurations).</li><li>点 + 并选择 JAR Application.</li></ol><h2 id="部署-artifacts-到application-servers-和-cloud-platforms"><a href="#部署-artifacts-到application-servers-和-cloud-platforms" class="headerlink" title="部署 artifacts 到application servers 和 cloud platforms"></a>部署 artifacts 到application servers 和 cloud platforms</h2><p>有很多 artifact 格式 （比如 WAR，Exploded WAR, EAR, Exploded EAR) 都适合部署到程序服务器和云服务器，下面是部署步骤：</p><ol><li>在服务器 或者 远程服务器 run/debug configuration，指定 artifact 来部署。</li><li>运行 run/debug configuration 或者 在 <strong>Application Servers</strong>, <strong>Run</strong> or <strong>Debug</strong> tool window 上使用 <strong>Deploy</strong> 图标。</li></ol><h2 id="artifact-与-exploded-artifact-的区别"><a href="#artifact-与-exploded-artifact-的区别" class="headerlink" title="artifact 与 exploded artifact 的区别"></a>artifact 与 exploded artifact 的区别</h2><p>artifact 是 exploded artifact 打包后的产品， 而 exploded artifact 是文件夹结构的，除了这个区别，在Tomcat 部署这两种 artifact 的时候，调试的时候也有一定区别。详见 <a href="/idea-tomcat">Intelij Idea 使用 Tomcat 运行/调试 Web 应用 （超详细）</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> openvpn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Intelij Idea 使用 Tomcat 运行/调试 Web 应用 （超详细）</title>
      <link href="/idea-tomcat/"/>
      <url>/idea-tomcat/</url>
      
        <content type="html"><![CDATA[<p>工欲善其事必先利其器，本文拟用 Intellij Idea 来启动 Tomcat 运行/调试 Web 应用，深入 Idea 与 Tomcat 结合调试，减少项目部署时间。</p><a id="more"></a><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ol><li>Run Configuration -&gt; 新建 Tomcat Run Configuration</li></ol><p><img src="/images/idea/1.png" alt="image"></p><ol><li><p>选择当更新操作(Ctrl + F10)或者 Intellij Idea 失去焦点的时候更新Tomcat 中的 classes和资源（热交换）<br><img src="/images/idea/2.png" alt="image"></p></li><li><p>选择部署的artifact，这里选 war exploded, 为什么不选 war, 因为war是war exploded 打包后的， war exploded 不打包，而且 war 不支持 静态资源的热部署<br><img src="/images/idea/3.png" alt="image"></p></li></ol><ol><li>Run/Debug </li></ol><p><img src="/images/idea/4.png" alt="image"></p><h2 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h2><p>设置 Tomcat 配置的时候可以看到， On Update action 和 On frame deactivation， 这个是指什么，接下来会介绍。</p><h3 id="On-‘Update’-action"><a href="#On-‘Update’-action" class="headerlink" title="On ‘Update’ action"></a>On ‘Update’ action</h3><p>顾名思义，更新操作，是指 ‘Update application’， 快捷键为 Ctrl + F10 ，或者点击运行/调试 View左下角，与 Build Project/Module(Ctrl + F9) 不是同一个概念</p><p><img src="/images/idea/5.png" alt="image"></p><p>对于 exploded artifacts ， 可选的选项为</p><ul><li>Update Resources. 所有改变的资源都更新（CSS、HTML、JS等）</li><li>Update classes and resources. 所有改变的资源和改变的Java 类都重新编译更新  </li></ul><blockquote><p>在 Debug 模式下, 更新的类可以热交换(hot swapped). 在 Run 模式下, IntelliJ IDEA 只更新输出文件夹中的改变的类. 这个类实际上到底重载没有，取决于运行环境的兼容性。</p></blockquote><ul><li>Redeploy. 应用 artifact 重新构建和重新部署</li><li>Restart Server. 服务器重启，应用 artifact 重新构建和重新部署</li></ul><p>对于 packed artifacts （不带exploded的)，可选的选项为</p><ul><li>Hot swap classes. 改变的类重新编译和在运行时重加载. 只在 <strong>debug</strong> 模式下有用</li><li>Redeploy. 应用 artifact 重新构建和重新部署</li><li>Restart Server. 服务器重启，应用 artifact 重新构建和重新部署</li></ul><h2 id="On-frame-deactivation"><a href="#On-frame-deactivation" class="headerlink" title="On frame deactivation"></a>On frame deactivation</h2><p>这个名词的意思即 从Intellij idea 切换到其他程序，触发的操作。除了<br>Do nothing 选项，其他选项都跟 ‘On Update action’一致。</p><h2 id="Deploy-applications-configured-in-Tomcat-instance"><a href="#Deploy-applications-configured-in-Tomcat-instance" class="headerlink" title="Deploy applications configured in Tomcat instance"></a>Deploy applications configured in Tomcat instance</h2><p>勾选上这个选项，这样就会部署 tomcat 中的其他应用， 比如</p><ul><li>docs</li><li>examples</li><li>host-manager</li><li>manager</li><li>ROOT</li></ul>]]></content>
      
      
      <categories>
          
          <category> intellij idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> intellij idea </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 搭建 OpenVPN 翻墙</title>
      <link href="/openvpn/"/>
      <url>/openvpn/</url>
      
        <content type="html"><![CDATA[<p>本文以 Ubuntu 为服务器搭建 OpenVPN 实现翻墙与外网客户端访问服务端内网。</p><a id="more"></a><h2 id="安装openvpn与easyrsa-（证书生成工具）-并启动"><a href="#安装openvpn与easyrsa-（证书生成工具）-并启动" class="headerlink" title="安装openvpn与easyrsa （证书生成工具） 并启动"></a>安装openvpn与easyrsa （证书生成工具） 并启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openvpn easy-rsa</span><br></pre></td></tr></table></figure><p>首先把配置文件模板拷贝到/etc/openvpn/目录下，再解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/</span><br><span class="line">sudo gzip -d /etc/openvpn/server.conf.gz</span><br></pre></td></tr></table></figure><p>然后把easy-rsa拷贝到openvpn的配置目录下，方便操作<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/openvpn/easy-rsa/</span><br><span class="line">cp -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa/</span><br></pre></td></tr></table></figure></p><p>切换到easy-rsa目录，并且清除之前生成的keys(如果有)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/easy-rsa/</span><br><span class="line">./clean-all</span><br><span class="line">./build-ca #生成ca证书</span><br></pre></td></tr></table></figure></p><p>生产服务器证书，这里有个坑，当询问到最后一步的时候一定要按y，不然会生成空的证书</p><blockquote><p>As in the previous step, most parameters can be defaulted. Two other queries require positive responses, “Sign the certificate? [y/n]” and “1 out of 1 certificate requests certified, commit? [y/n]”.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key-server myservername</span><br></pre></td></tr></table></figure><p>生成Diffie Hellman 参数(可能有点慢):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure><p>现在所有的证书都在 <code>/etc/openvpn/easy-rsa/keys/</code> 里了，现在需要拷贝出来，拷贝到 openvpn 配置文件夹里面 (/etc/openvpn)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd keys/</span><br><span class="line">cp myservername.crt myservername.key ca.crt dh2048.pem /etc/openvpn/</span><br></pre></td></tr></table></figure><p>最后，还需要生成一个秘钥 <code>ta.key</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --genkey --secret ta.key</span><br></pre></td></tr></table></figure><p>现在可以看到/etc/openvpn目录有的证书与秘钥如下：</p><p><code>myservername.crt myservername.key ca.crt dh2048.pem ta.key</code></p><p>现在开始修改openvpn配置文件，让配置文件对应刚刚拷贝过来的证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/openvpn/server.conf</span><br><span class="line"></span><br><span class="line">ca ca.crt</span><br><span class="line">cert myservername.crt</span><br><span class="line">key myservername.key</span><br><span class="line">dh dh2048.pem</span><br><span class="line">tls-auth ta.key 0</span><br></pre></td></tr></table></figure><p>现在服务器就配置完成了，启动试试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start openvpn@server</span><br></pre></td></tr></table></figure></p><p>启动成功！<br>看看日志:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status openvpn@server</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journal -u openvpn@server</span><br></pre></td></tr></table></figure></p><h2 id="制作客户端证书"><a href="#制作客户端证书" class="headerlink" title="制作客户端证书"></a>制作客户端证书</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/easy-rsa/</span><br><span class="line">./build-key client1</span><br></pre></td></tr></table></figure><p>然后把下列证书与秘钥传送到客户端所在机器</p><ol><li>/etc/openvpn/ca.crt</li><li>/etc/openvpn/easy-rsa/keys/client1.crt</li><li>/etc/openvpn/easy-rsa/keys/client1.key</li><li>/etc/openvpn/ta.key</li></ol><h2 id="Windows-客户端配置"><a href="#Windows-客户端配置" class="headerlink" title="Windows 客户端配置"></a>Windows 客户端配置</h2><p>1.先在官网下一份openvpn客户端，在安装目录找到sample-config文件夹，找到client.ovpn，拷贝到安装目录的config文件夹。</p><p>2.然后将服务器上制作的客户端证书与秘钥传送到config文件夹。</p><p>3.修改一下client.ovpn配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert client1.crt</span><br><span class="line">key client1.key</span><br><span class="line">tls-auth ta.key 1</span><br></pre></td></tr></table></figure></p><p>4.找到系统托盘，连接！连接成功，现在ping 10.8.0.x （openvpn服务器的IP) 成功，<strong>但是现在还不能翻墙</strong>！</p><h2 id="OpenVpn-翻墙配置"><a href="#OpenVpn-翻墙配置" class="headerlink" title="OpenVpn 翻墙配置"></a>OpenVpn 翻墙配置</h2><p>首先需要配置Ubuntu支持流量转发，编辑 /etc/sysctl.conf<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">net.ipv4.ip_forward=1</span></span><br></pre></td></tr></table></figure></p><p>把注释去掉，然后重新加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p><p>修改openvpn配置 <code>/etc/openvpn/server.conf</code>，使其重定向客户端流量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push &quot;redirect-gateway def1 bypass-dhcp&quot;</span><br></pre></td></tr></table></figure></p><p>修改dns<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push &quot;dhcp-option DNS 8.8.8.8&quot;</span><br></pre></td></tr></table></figure></p><p>重启openvpn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart openvpn@server</span><br></pre></td></tr></table></figure></p><p>现在用客户端连上发现不能上网了，只能访问openvpn这台机器！是因为openvpn把客户端的所有流量都转发了，但是服务端并没有配置流量转发到外网。  </p><p>设置 iptables 转发10.8.0.x 的所有流量到外网:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE</span><br></pre></td></tr></table></figure></p><p>现在访问Google，OK！</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> openvpn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何使用 Systemd 为 Shadowsocks 添加开机启动服务</title>
      <link href="/systemd/"/>
      <url>/systemd/</url>
      
        <content type="html"><![CDATA[<p>本文以 Shadowsocks 为例，如何使用 Systemd 为 Shadowsocks 添加开机启动，</p><a id="more"></a><h2 id="安装-Shadowsocks"><a href="#安装-Shadowsocks" class="headerlink" title="安装 Shadowsocks"></a>安装 Shadowsocks</h2><p>首先是下载 Shadowsocks</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shadowsocks</span><br></pre></td></tr></table></figure><p>安好shadowsocks后，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -k mypass</span><br></pre></td></tr></table></figure><p>这样就启动了一个 Shadowsocks 前台程序，即程序会占用终端的输出。当然可以使用<code>ssserver -k mypass -d start</code>自带的daemon后台程序托管Shadowsocks，但是本文的目的是使用Systemd来管理Shadowsocks并实现开机自动启动。</p><h2 id="使用-Systemd-托管-Shadowsocks"><a href="#使用-Systemd-托管-Shadowsocks" class="headerlink" title="使用 Systemd 托管 Shadowsocks"></a>使用 Systemd 托管 Shadowsocks</h2><p>想要成为Systemd 一个服务，可以通过在其指定目录下添加 systemd单元配置文件，即在<br><code>/usr/lib/system.d/system</code> 和 <code>/etc/system.d/system</code> 目录添加<br><code>ss.service</code>文件即可，<code>ss</code>则是这个服务的服务名</p><p>添加服务单元配置文件，首先需要一个systemd配置文件的模板，这里以ssh.service为例，复制一份ssh.service的模板再修改我们所需要的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl cat ssh.service &gt; /usr/lib/system.d/system/ss.service</span><br></pre></td></tr></table></figure><p>修改完毕的ss.service…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># /lib/systemd/system/ss.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/ssserver -k mypass</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重新加载一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd daemon-reload</span><br></pre></td></tr></table></figure><p>查看已经加载的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status ss.service</span><br></pre></td></tr></table></figure><p>可以看到目前是inactive的，即还没有启动，现在启动这个服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start ss.service</span><br></pre></td></tr></table></figure></p><p>现在还没有设置开机启动，可以看到状态是disabled</p><h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>使其开机自动启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable ss.service</span><br></pre></td></tr></table></figure></p><p>现在用<code>systemctl status ss.service</code>查看状态可以看到ss服务正在运行，并且最下方是它的日志</p><h2 id="维护Shadowsocks-访问-Shadowsocks-日志"><a href="#维护Shadowsocks-访问-Shadowsocks-日志" class="headerlink" title="维护Shadowsocks - 访问 Shadowsocks 日志"></a>维护Shadowsocks - 访问 Shadowsocks 日志</h2><p>如果遇到一些奇怪的情况，客户端使用这个ss服务器并没有效果，这时候需要借助Shadowsocks 日志来确定问题的所在。<br>除了用systemctl status ss.service 查看其部分日志，还可以使用更方便的查看日志的命令组jouralctl</p><p>查看ss这个服务的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jouralctl -u ss</span><br></pre></td></tr></table></figure></p><p>如果忘记这个服务名了，查看所有日志试试看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jouralctl -xe</span><br></pre></td></tr></table></figure></p><p>如果只记得服务名中含有s这个单词，使用s查找服务名<br>列出服务状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit | grep s 或 systemctl | grep s</span><br></pre></td></tr></table></figure></p><p>列出服务开机是否启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-file --type=service | grep s</span><br></pre></td></tr></table></figure></p><p>PS.</p><ul><li><code>/usr/lib/systemd/system/</code> ：软件包安装的单元<br>– 注解: Ubuntu 还有 <code>/lib/systemd/system/</code></li><li><code>/etc/systemd/system/</code>：系统管理员安装的单元，开机启动的单元目录  </li></ul><p>开机时间小助手<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemd-analyze blame #查看各个服务的开机启动时间</span><br><span class="line">systemd-analyze plot &gt; boot.svg #导出开机时间图</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> systemd </tag>
            
            <tag> shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP 协议深究</title>
      <link href="/http/"/>
      <url>/http/</url>
      
        <content type="html"><![CDATA[<p>HTTP 协议深究。</p><a id="more"></a><h1 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h1><p>因特网上有数千种不同的数据类型，HTTP都要给每种传输对象打上名为MIME类型，MIME 类型原为电子邮件中使用。全称是 <code>Multipurpose Internet Mail Extension</code>。</p><p>Header 中的 <code>Content-Type</code> 就是MIME类型。</p><p>MIME类型由一个主类型和子类型构成，中间加一条斜杠。以下是常见的一些MIME类型：</p><ul><li>HTML 由 text/html 标记</li><li>普通的ASCII文档 用 text/plain</li><li>JPEG 使用 image/jpeg</li><li>gif 使用 image/gif</li><li>powerPoint 使用 application/vnd.ms-powerpoint</li></ul><p>常见的MIME类型由数百个。</p><h1 id="资源访问"><a href="#资源访问" class="headerlink" title="资源访问"></a>资源访问</h1><ul><li>URI 统一资源标识符</li><li>URL 统一资源定位符 url = schema + host + resource_url</li><li>URN 统一资源名称(比如 urn:ietf:rfc:2141)</li></ul><p>大多数URL方案的URL语法是这样子的：</p><pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?#&lt;frag&gt;</code></pre><p>为了使用安全字符集的使用限制（US-ASCII），出现编码转义%，由百分号和表示字符的ASCII码的十六进制形式，如%20代表空格(ASCII，32)。</p><h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><p>请求行与请求头是使用 CRLF 即回车换行符 <code>\r\n</code> 分割的。</p><p>请求头与请求头之间是使用 CRLF 分割的。</p><p>请求头以一个空行<code>\r\n</code>结束。</p><p>同理回应行、回应头。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>五种常见的HTTP方法。</p><ul><li>GET 获取 请求不带消息体</li><li>PUT 保存 请求带消息体</li><li>DELETE 删除 请求不带消息体</li><li>POST 提交 请求带消息体</li><li>HEAD 仅发送HTTP首部 请求不带消息体</li></ul><p>另外两种。</p><ul><li>OPTIONS 获取可用的请求方法。通过回复头 Allow 回复。请求不带消息体</li><li>TRACE 跟踪代理。通过回复头 Via 回复。请求不带消息体。</li></ul><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>常见的HTTP状态码。</p><ul><li>200 OK</li><li>302 Redirect</li><li>404 Not Found</li><li>500 Internal Server Error</li></ul><h2 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h2><p>通过客户端的请求头 Expect: 100 Continue 说明客户端将后续发送请求体， 当客户端收到服务端返回的100状态码，然后才将实体发送给服务端，当然，客户端如果到了超时时间却没有收到服务端的100状态码，也会继续发送。</p><h1 id="报文-1"><a href="#报文-1" class="headerlink" title="报文"></a>报文</h1><p>HTTP报文都是纯文本，不是二进制代码。报文包含：起始行、首部、主体。</p><p>首部以<strong>一个空行</strong>结束。</p><p>Content-Length 说明了<strong>响应主体</strong>的长度。</p><h1 id="Web-结构组件"><a href="#Web-结构组件" class="headerlink" title="Web 结构组件"></a>Web 结构组件</h1><ul><li>代理 </li><li>代理缓存</li><li>网关 将HTTP流量转换成其他的协议。比如http-&gt;ftp</li><li>隧道 对数据进行盲转发</li><li>Agent 代理</li></ul><p>未完待续…</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《HTTP 权威指南》</p>]]></content>
      
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minecraft 制造计算机（二） - 半加器</title>
      <link href="/logic-gate-and-mc-2/"/>
      <url>/logic-gate-and-mc-2/</url>
      
        <content type="html"><![CDATA[<p>通过逻辑门来造加法器辣。</p><a id="more"></a><h1 id="制表"><a href="#制表" class="headerlink" title="制表"></a>制表</h1><p>有了上一篇 <a href="/logic-gate-and-mc-1/" title="Minecraft 制造计算机（一） - 逻辑门">Minecraft 制造计算机（一） - 逻辑门</a> 的基础，下面介绍如何使用逻辑门造一个半加器。</p><p>先来看一看二进制的加法:</p><pre><code>1 + 0 = 10 + 1 = 10 + 0 = 01 + 1 = 10</code></pre><p>这就是二进制加法表，如果将二进制加法的值拆分为进位、和，其对应的表格如下:</p><p>进位表(与)：</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p><img src="/images/mc/NANDgate.png" alt=""></p><p>和表(异或):</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/XORgate.png" alt=""></p><h1 id="制造"><a href="#制造" class="headerlink" title="制造"></a>制造</h1><p>可以看到，进位表就是一个逻辑与、而和表就是一个逻辑异或。有了基础理论，半加器做起来也很容易了：</p><p><img src="/images/mc/09.jpg" alt=""></p><p><img src="/images/mc/10.gif" alt=""></p><p>开关的向上代表0，向下代表1，灯泡的亮表示1暗表示0，正好符合加法表：</p><pre><code>0 0 得 01 0 得 10 1 得 11 1 得 10</code></pre><p>做出了半加器，下一篇  将描述如何制作全加器</p>]]></content>
      
      
      <categories>
          
          <category> minecraft 造计算机系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logic-gates </tag>
            
            <tag> minecraft </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark 计算文章相似度</title>
      <link href="/spark-similarity/"/>
      <url>/spark-similarity/</url>
      
        <content type="html"><![CDATA[<p>如何使用 Spark 并行计算文章与文章之间的相似度？</p><a id="more"></a><h1 id="计算TF-IDF"><a href="#计算TF-IDF" class="headerlink" title="计算TF-IDF"></a>计算TF-IDF</h1><p>Term frequency-inverse document frequency（词频-逆文档频率）是一个向量化的标识，用于反应一个术语在整篇文档中的重要性。</p><p>用 t 表示一个术语(term)， d 表示文档(document)，D 表示语料库(corpus)。</p><p>( TF(t,d) ) Term Frequency 表示<strong>术语t</strong>在文档d中<strong>的个数</strong>。</p><p>( DF(t, D) ) Document Frenquency 表示在语料库中包含术语t的<strong>文档的个数</strong>。</p><p>逆文档频率是一个数字，用于测量一个术语提供了多大的信息量。</p><p>  $$ IDF(T, D) = log \frac{|D|+1}{DF(t,D)+1} $$ </p><p>也就是，</p><p>  $$ 逆文档频率 = log \frac{语料库的文档个数+1}{包含术语t的文档个数+1} $$</p><p>也就是说，包含术语t的文档个数越多，逆文档频率越小，加一是为了避免除0。TD-IDF 度量可以简单的表示为TF和IDF的乘积：</p><p>  $$ TFIDF(t, d, D) = TF(t,d)*IDF(T,D) $$</p><p>TF-IDF 表示了一个术语在文章中的重要程度，如果将一篇文章中TF-IDF组合起来，就构成了一个向量，同时，算出另外一篇文章的TF-IDF，将两篇文章的TF-IDF向量的相同词语分别对应同一个维度，再用余弦定理计算出两篇文章的余弦值，余弦值越大（最大1，向量重合），说明这两篇文章越相似。</p><p><strong>TF</strong>: 在 Spark 中，可以使用<code>HashingTF</code> 和 <code>CountVectorizer</code> 来计算TF（词频）。</p><p><strong>IDF</strong>: 在 Spark 中，使用<code>IDF</code>类来结算IDF从而计算出TF-IDF。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算tf</span></span><br><span class="line">        CountVectorizerModel countVectorizerModel = <span class="keyword">new</span> CountVectorizer().setInputCol(<span class="string">"words"</span>).setOutputCol(<span class="string">"rawFeatures"</span>).fit(wrappedWords);</span><br><span class="line">        Dataset&lt;Row&gt; featurizedData = countVectorizerModel.transform(wrappedWords);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算idf</span></span><br><span class="line">        IDF idf = <span class="keyword">new</span> IDF().setInputCol(<span class="string">"rawFeatures"</span>).setOutputCol(<span class="string">"features"</span>);</span><br><span class="line">        IDFModel idfModel = idf.fit(featurizedData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算tf-idf</span></span><br><span class="line">        Dataset&lt;Row&gt; rescaledData = idfModel.transform(featurizedData);</span><br></pre></td></tr></table></figure><h1 id="计算余弦相似度"><a href="#计算余弦相似度" class="headerlink" title="计算余弦相似度"></a>计算余弦相似度</h1><p>计算出 TF-IDF 后，将其转换为一个<code>BlockMatrix</code>矩阵。</p><pre><code>1 0 2.52078447201548 0 0 0 2.004684436494304 2.000347299268466 0 2.228387042742021 2.228387042742023 0 0 0 0 0 00 2.857738033247042 0 0 2.619965104088255 0 2.004684436494304 2.000347299268466 0 2.228387042742021 2.228387042742023 0 0 0 0 0 00 2.857738033247042 0 2.061393766919624 0 0 2.004684436494304 0 0 2.228387042742021 2.228387042742023 0 0 0 0 0 01 0 0 2.061393766919624 2.619965104088255 0 2.004684436494304 2.000347299268466 0 0 0 0 2.055002875864414 0 0 0 01 2.857738033247042 0 2.061393766919624 2.619965104088255 0 2.004684436494304 0 0 0 0 0 2.055002875864414 0 0 0 0</code></pre><p>计算出矩阵后，将其倒置。</p><p>倒置后将<code>BlockMatrix</code>转换为<code>RowMatrix</code>并使用 RowMatrix 的 columnSimilarities 这个方法将计算出每一列的余弦相似度，其结果也是一个矩阵(CoordinateMatrix)。矩阵的横坐标i代表其中某一列，纵坐标j代表另外一列，其余弦值结果就是Entry(i,j)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将稀疏向量转变为密集向量</span></span><br><span class="line">       JavaRDD&lt;Vector&gt; features = (JavaRDD&lt;Vector&gt;)rescaledData.toJavaRDD().map(<span class="keyword">new</span> Function&lt;Row, Vector&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Vector <span class="title">call</span><span class="params">(Row row)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               SparseVector features = row.getAs(<span class="string">"features"</span>);</span><br><span class="line">               <span class="keyword">return</span> Vectors.dense(features.toArray());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//构建带索引的矩阵，用于转化为分块向量</span></span><br><span class="line">       JavaRDD&lt;IndexedRow&gt; indices = (JavaRDD&lt;IndexedRow&gt;)features.zipWithIndex().map(<span class="keyword">new</span> Function&lt;Tuple2&lt;Vector, Long&gt;, IndexedRow&gt;() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> IndexedRow <span class="title">call</span><span class="params">(Tuple2&lt;Vector, Long&gt; t)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> IndexedRow(t._2(), t._1());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//得到分块矩阵的转置</span></span><br><span class="line">       BlockMatrix blockMatrix = <span class="keyword">new</span> IndexedRowMatrix(indices.rdd()).toBlockMatrix().transpose();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//得到行矩阵</span></span><br><span class="line">       RowMatrix rowMatrix = blockMatrix.toCoordinateMatrix().toRowMatrix();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计算行矩阵的列相似度，获得带坐标的相似度矩阵（结果输出）</span></span><br><span class="line">       CoordinateMatrix res = rowMatrix.columnSimilarities();</span><br></pre></td></tr></table></figure><p>计算出余弦值结果后再将通过文章id和i、j的映射取出对应的文章id，文章与文章的相似度也就能保存在数据库中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将相似度矩阵转换，并存储数据库。</span></span><br><span class="line">       JavaRDD&lt;Document&gt; documents = (JavaRDD&lt;Document&gt;)res.entries().toJavaRDD().map(<span class="keyword">new</span> Function&lt;MatrixEntry, Document&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> Document <span class="title">call</span><span class="params">(MatrixEntry entry)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               Document d = <span class="keyword">new</span> Document();</span><br><span class="line">               d.put(<span class="string">"id1"</span>, ids.get(<span class="keyword">new</span> Long(entry.i()).intValue()));</span><br><span class="line">               d.put(<span class="string">"id2"</span>, ids.get(<span class="keyword">new</span> Long(entry.j()).intValue()));</span><br><span class="line">               d.put(<span class="string">"score"</span>, entry.value());</span><br><span class="line">               <span class="keyword">return</span> d;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p><a href="https://databricks.com/blog/2014/10/20/efficient-similarity-algorithm-now-in-spark-twitter.html" target="_blank" rel="noopener">感谢 databricks 的文章</a></p><p>columnSimilarites 计算余弦相似度采用TWITTER的 DIMSUM 算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minecraft 制造计算机（一） - 逻辑门</title>
      <link href="/logic-gate-and-mc-1/"/>
      <url>/logic-gate-and-mc-1/</url>
      
        <content type="html"><![CDATA[<p>如何在 Minecraft 中制造逻辑门？</p><a id="more"></a><h2 id="现实世界中的逻辑门"><a href="#现实世界中的逻辑门" class="headerlink" title="现实世界中的逻辑门"></a>现实世界中的逻辑门</h2><p>上一篇 <a href="/bool">布尔代数与计算机</a> 中介绍了如何使用电路来表示布尔逻辑运算，使用<br>串联来表示与运算（交集），使用并联来表示或运算（并集），其实它们都有一个专门的名字：与门、或门。</p><p>与门：<br><img src="/images/bool/01.png" alt=""></p><p>或门：<br><img src="/images/bool/02.png" alt=""></p><p>当输入为0，输出为其取反即0时，这种逻辑电路称为反向器。</p><h2 id="Minecraft-红石电路基本元件"><a href="#Minecraft-红石电路基本元件" class="headerlink" title="Minecraft 红石电路基本元件"></a>Minecraft 红石电路基本元件</h2><p>因此，通过串联，并联，并通过电路是否通电来表示数学中的逻辑运算。Minecraft 中红石电路可以实现基本的逻辑门，从而可以制造出加法器、减法器、锁存器等等。</p><p>Minecraft 中关于红石电路和逻辑门的信息（只讨论使用基本的红石电路，不包括光敏传感器等）；</p><ul><li>红石电源有好几种：拉杆（开关）、红石火把</li><li>开关常用于逻辑门，因为他们易于制作和使用</li><li>当红石火把有供电，他们反而会熄灭，并停止提供电源(<strong>重要！</strong>)</li></ul><h2 id="关键图"><a href="#关键图" class="headerlink" title="关键图"></a>关键图</h2><p><img src="/images/mc/MCGatesKey.png" alt=""><br>从左至右：</p><ol><li>空气（空）</li><li>开关（电源）</li><li>方块（通用）</li><li>红石火把（方块侧）</li><li>红石火把（地上）</li><li>红石火把（方块上）</li><li>红石（地上）</li><li>红石（方块上）</li><li>红石（输出）</li></ol><h2 id="逻辑门的制作"><a href="#逻辑门的制作" class="headerlink" title="逻辑门的制作"></a>逻辑门的制作</h2><h2 id="反向器"><a href="#反向器" class="headerlink" title="反向器"></a>反向器</h2><p>是一个电源与输出状态相反的逻辑元件。当电源开着，则输出会关掉，反之亦然。</p><table><thead><tr><th>电源</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/NOTgate.png" alt=""></p><p>游戏中实际表示为：</p><p><img src="/images/mc/01.png" alt=""></p><h2 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h2><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><p><img src="/images/mc/ORgate.png" alt=""></p><p>游戏中实际表示为：</p><p><img src="/images/mc/02.png" alt=""></p><h2 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h2><p>与门稍微复杂些，这与MC中开关即电源有关系。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p><strong>错误的表示方法</strong>， 因为开关就是一个电源！ 这样的话只要开启后一个开关灯就会亮了：</p><p><img src="/images/mc/03.png" alt=""></p><p><strong>正确的表示方法</strong>:</p><p><img src="/images/mc/ANDgate.png" alt=""></p><p><img src="/images/mc/08.png" alt=""></p><p>既然不能直接构造与门，这里使用了2个反向器与一个或门再加一个反向器，根据德·摩根定律：</p><p>$$ A \land B = \neg ( \neg (A \land B)) = \neg ( \neg A \lor \neg B) $$ </p><p>即与门可以用反向器和或门表示。</p><h2 id="或非门"><a href="#或非门" class="headerlink" title="或非门"></a>或非门</h2><p>或非门即或门取反。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/NORgate.png" alt=""></p><p><img src="/images/mc/06.png" alt=""></p><h2 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h2><p>与非门即与门取反。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/NANDgate.png" alt=""></p><p><img src="/images/mc/07.png" alt=""></p><h2 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h2><p>相同即为0，不同即为1。异或门由 或门、与非门、与门构成，或门与与非门的输出作为与门的输入。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p><img src="/images/mc/04.png" alt=""></p><p><img src="/images/mc/XORgate.png" alt=""></p><h2 id="同或门"><a href="#同或门" class="headerlink" title="同或门"></a>同或门</h2><p>相同即为1，不同即为0，即异或门取反。只需要在异或门后面取反就行了。</p><table><thead><tr><th>电源</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td>0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td>1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p><img src="/images/mc/XNORgate.png" alt=""></p><p>下面将使用这些逻辑门做一个半加器 <a href="/logic-gate-and-mc-2/" title="Minecraft 制造计算机（二） - 半加器">Minecraft 制造计算机（二） - 半加器</a> 吧。</p>]]></content>
      
      
      <categories>
          
          <category> minecraft 造计算机系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logic-gates </tag>
            
            <tag> minecraft </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark 快速入门教程（三） - 搭建集群</title>
      <link href="/spark-3/"/>
      <url>/spark-3/</url>
      
        <content type="html"><![CDATA[<p>如何搭建Spark集群？</p><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>搭建集群前需要了解 Spark 集群的一些术语：</p><ul><li>Driver 驱动器，也就是程序入口，带main函数的那个程序。</li><li>Master 主节点，并不会参与预算，只是用作管理集群。不要和Driver混淆，Master≠Driver。节点都是指<strong>机器</strong>，Driver是指带main函数的<strong>程序</strong>。Driver可以运行在Master上，也可以运行在Worker上，还可以运行在这两者之外的远程机器上。</li><li>Worker 计算节点，Spark RDD运算时就是在计算节点上执行的。</li><li>Executor 执行器，这个是运行在 Worker 上的真正的执行程序，这是一个<strong>进程</strong>，是由 Worker 上的 spark 开启并管理的，也就是说在 Worker 的 spark 程序开启远程调试，由调试客户端进行调试时，并不能成功的调试 Executor 完成 Jobs 的过程。</li></ul><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>在主节点 Master 上添加 Worker 很简单，在根目录 <code>/conf/slaves</code> 配置文件添加 Worker节点 ip 或 主机名（主机名可用ssh配置）即可，也可以把自己也添加进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost</span><br><span class="line">192.168.2.230</span><br></pre></td></tr></table></figure><p>启动<code>/sbin/start-all</code>，集群开始运行，报错…无法连接到目标主机。</p><p>当然，直接启动另外一台电脑上的程序肯定不会成功，要能成功连接到 Worker，需要配置 ssh ，必须让 Master 能无密码连接到 Worker 才能启动 Worker 节点的 Spark。</p><ol><li>Worker <code>ssh-keygen -t rsa</code> 生成秘钥，并添加 authorized_keys, <code>cat id_rsa &gt; authorized_keys</code></li><li>将 Worker 的秘钥发送到 Master <code>scp ~/.ssh/id_rsa root@master:/.ssh/</code> </li><li>配置 ssh_config</li></ol><p>连接测试 ssh 到 Worker 后，<code>/sbin/start-all</code> 成功。</p><h1 id="关于启动-Worker-的两个脚本"><a href="#关于启动-Worker-的两个脚本" class="headerlink" title="关于启动 Worker 的两个脚本"></a>关于启动 Worker 的两个脚本</h1><p><code>/sbin/</code> 下有两个脚本 <code>start-slaves.sh</code> 和 <code>start-slave.sh</code>，他们的区别是前者启动本Master管理的所有 Worker节点（启动别人），而<code>start-slave.sh</code>需要指定一个Master，当本机作为Worker 节点并且挂了的时候，需要重新连接到Master时使用。</p><h1 id="部署模式-deploy-mode-Cluster-与-Client"><a href="#部署模式-deploy-mode-Cluster-与-Client" class="headerlink" title="部署模式(deploy mode) Cluster 与 Client"></a>部署模式(deploy mode) Cluster 与 Client</h1><p>部署模式决定了Driver是在本地运行还是在集群上运行，Client是本地运行，而Cluster是在集群上的某一个 Worker上运行，默认是Client。通过指定spark-submit的参数–deploy-mode来指定，注意，如果是cluster模式，刚好选中的Worker必须要有驱动器程序，而且工作路径 和 提交driver时所在机器的所在路径一致, 也就是说，如果你在windows上提交driver，使用 Cluster 模式， 而选中的 Worker 是 linux系统，这是肯定不能执行成功的，因为在linux执行 driver 时，使用的是windows系统的盘符。</p>]]></content>
      
      
      <categories>
          
          <category> spark 入门系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>布尔代数与计算机</title>
      <link href="/bool/"/>
      <url>/bool/</url>
      
        <content type="html"><![CDATA[<p>如何使用布尔代数制造一个计算机？</p><a id="more"></a><p>在古希腊时期，有一段著名的亚里士多德三段论：</p><blockquote><p>人总是要死的。<br>  苏格拉底是人。<br>  所以，苏格拉底是要死的。</p></blockquote><p>三句话虽然看起来很直白，但是却无法用数学证明，人们总是用代数来代表数字，无法用数学表示逻辑。</p><p>直到 乔治·布尔 ——</p><p><img src="/images/bool/04.png" alt=""></p><p>他提出了一个与常规代数相似而又不相同的代数——布尔代数。其与常规代数最大的不同就是，常规代数表示的是数字，而布尔代数表示的是集（类），使代数更加抽象。</p><p>他将集的操作分为两类：</p><p>＋：两个集合的并集<br>×：两个集合的交集</p><p>其运算符合以下性质，使用 0 代表空集，使用 1 代表全集，使用 (1 － A) 代表A的补集：</p><p>交换律：A ＋ B = B ＋ A<br>结合律：(A ＋ B) ＋ C = A + (B + C)<br>    (A × B) × C = A × (B × C)<br>分配律：(A ＋ B) × C = A × C + B × C<br>    (A × B) ＋ C = (A ＋ C) × (B ＋ C)<br>全集与空集：A ＋ 0 = A<br>        A ＋ 1 = A<br>补集：    A ＋ (1 － A) = 1<br>        A × (1 － A) = 0<br>德·摩根定律：1 － (A＋B) = (1 － A) × (1 － B)<br>          1 － (A×B) = (1 － A) ＋ (1 － B)</p><p>这是最初布尔用的＋×符号，后来人们为了与传统代数运算区分开，亦可使用∪、∩、ˉ代表集合的并、交、补。</p><p>注意，和传统代数有区别的是 <code>(A × B) ＋ C = (A ＋ C) × (B ＋ C)</code> 这在传统代数中是不成立的。</p><p>于是，将人用P表示，要死的东西用M表示，苏格拉底用S表示。<br>由第一句话，人总是要死的可以推出：</p><pre><code>P × M = P</code></pre><p>为什么不是 P × M = M 呢， 因为要死的东西不只是人，还有其他动物植物。<br>由第二句话， 苏格拉底是人可以推出：</p><pre><code>S × P = S</code></pre><p>为什么不是 S × P = P ，因为不只是只有苏格拉底一个人。<br>将第一个式子 P × M = P 带入第二个式子：</p><pre><code>S × (P × M) = S</code></pre><p>根据结合律：</p><pre><code>(S × P) × M = S</code></pre><p>由于第二个式子 S × P = S ，所以</p><pre><code>S × M = S</code></pre><p>由此推断，苏格拉底和要死的东西取交集就是苏格拉底，推出第三个句话的结论：苏格拉底会死。如果 S × M = 0 说明，苏格拉底会永生，如果 S × M = M，说明只有苏格拉底要死，其他生物都不会死。</p><p>布尔代数除了能集合运算，还能进行逻辑运算，逻辑运算使用 AND、OR、NOT分别代表集合中的 交集、并集、补集。用逻辑运算的符号表示是 ∨、∧、「。</p><p>如果能只用2种状态来表示集合，就出现了逻辑演算。用 1 代表真(全集)、 0 代表假(空集)，就会出现以下的表格：</p><table><thead><tr><th style="text-align:center">∨</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><table><thead><tr><th style="text-align:center">∧</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table><p>假设要买一只猫，跟店员说“我想要一只绝育的公猫，白色或黄褐色的，或者一只除了白色的绝育母猫，再或者只要是黑猫就行”。</p><p>用 M 代表公猫、F 代表母猫。白色 W、黄褐色 T、黑色 B、其他颜色 O 。N 绝育、U 没有绝育。</p><p>所以用集合来表示这个逻辑为：</p><pre><code>(M × N × (W ＋ T)) ＋ (F × N × (1 一 W)) + B</code></pre><p>接下来店员将一只猫做布尔测试，看看到底这只猫符不符合我的要求，发现用集合表示并不方便。于是使用逻辑来表示：</p><pre><code>(M AND N AND (W OR T)) OR (F AND N AND NOT W)) OR B</code></pre><p>当店员拿来一直白色未绝育公猫，用 1 代表 YES, 0 代表 NO，代入上面的逻辑表达式。</p><pre><code>(1 AND 0 AND (1 OR 0 )) OR (0 AND 0 AND NOT 1)) OR 0(1 * 0 * (1 + 0)) + (0 * 0 * (1 - 1)) + 0 = 0</code></pre><p>所以这只猫并不符合。</p><p>店员每次手动测试猫是不是符合要求，为什么不适用电路来代替手工运算呢。</p><p>电路串联：</p><p><img src="/images/bool/01.png" alt=""></p><p>两个开关，1代表闭合，0代表断开，当且仅当两个开关为闭合的时候，灯才会亮。这与逻辑与是一致的。</p><p><img src="/images/bool/02.png" alt=""></p><p>电路并联：<br>仅有一个开关为闭合，或者两个开关都闭合，灯就会亮。这与逻辑或是一致的。</p><p>于是店员将测试猫的表达式转换成了电路，使用电路来测试猫是否符合要求。</p><p><img src="/images/bool/03.png" alt=""> </p><p>通过操作开关的闭合，根据灯泡的亮与不亮就能判断出这只猫是不是符合要求。</p><p>附录：</p><p>代码中的布尔运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> a = Math.random() &gt; <span class="number">0.5</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = Math.random() &gt; <span class="number">0.5</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> c = Math.random() &gt; <span class="number">0.5</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        compare(a || b, b || a); <span class="comment">//交换律</span></span><br><span class="line">        compare(a || (b || c), (a || b) || c); <span class="comment">//加法结合律</span></span><br><span class="line">        compare(a &amp;&amp; (b &amp;&amp; c), (a &amp;&amp; b) &amp;&amp; c); <span class="comment">//乘法结合律</span></span><br><span class="line">        compare(a &amp;&amp; (b || c), a &amp;&amp; b || a &amp;&amp; c); <span class="comment">//分配律</span></span><br><span class="line">        compare(a || (b &amp;&amp; c), (a || b) &amp;&amp; (a || c)); <span class="comment">//分配律</span></span><br><span class="line">        compare(!(a &amp;&amp; b), !a || !b); <span class="comment">//德·摩根定律</span></span><br><span class="line">        compare(!(a || b ), !a &amp;&amp; !b);<span class="comment">//德·摩根定律</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">boolean</span> left, <span class="keyword">boolean</span> right)</span></span>&#123;</span><br><span class="line">        System.out.println(left == right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用0和1代替布尔值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> a = (<span class="keyword">byte</span>) (Math.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) (Math.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">byte</span> c = (<span class="keyword">byte</span>) (Math.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        compare(a | b, b | a);<span class="comment">//交换律</span></span><br><span class="line">        compare((a | b) | c, a | (b | c));<span class="comment">//加法结合律</span></span><br><span class="line">        compare((a &amp; b) &amp; c, a &amp; (b &amp; c));<span class="comment">//乘法结合律</span></span><br><span class="line">        compare(a &amp; (b | c), a &amp; b | a &amp; c);<span class="comment">//分配律</span></span><br><span class="line">        compare(a | (b &amp; c), (a | b) &amp; (a | c));<span class="comment">//分配律</span></span><br><span class="line">        compare(~(a &amp; b), ~a | ~b);<span class="comment">//德·摩根定律</span></span><br><span class="line">        compare(~(a | b ), ~a &amp; ~b);<span class="comment">//德·摩根定律</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        System.out.println(left == right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark 远程调试</title>
      <link href="/spark-debug/"/>
      <url>/spark-debug/</url>
      
        <content type="html"><![CDATA[<p>使用 java remote debug 功能， 借助intellij idea 远程调试 WordCount 程序。</p><a id="more"></a><p>Java 中进行远程调试步骤：</p><ol><li>在服务端配置启动参数，激活服务端的远程调试功能。</li><li>本地客户端连接调试服务端。</li><li>添加断点并且启动本地程序。</li></ol><p>配置 Master 远程调试： 配置 Spark java 运行参数。</p><p>找到 <code>SPARK_HOME/conf/spark-env.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPARK_MASTER_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure><p>修改后， 启动 Spark 集群 <code>SPARK_HOME/sbin/start-all.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep java | grep master</span><br><span class="line">root     21610     1  6 02:58 pts/0    00:00:05 /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.131-2.b11.el7_3.x86_64/jre/bin/java -cp /usr/<span class="built_in">local</span>/spark-2.1.0-bin-hadoop2.7/conf/:/usr/<span class="built_in">local</span>/spark-2.1.0-bin-hadoop2.7/jars/* -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5005 -Xmx1g org.apache.spark.deploy.master.Master --host 192.168.2.5 --port 7077 --webui-port 8080</span><br></pre></td></tr></table></figure><p>可以看到 java 运行参数已经被加上了。</p><p>添加 Spark Master 程序断点 <code>Master.scala</code></p><p><img src="/images/spark/spark-04.png" alt=""></p><p>点击调试按钮，连接调试服务端</p><p><img src="/images/spark/spark-02.png" alt=""></p><p><img src="/images/spark/spark-10.png" alt=""></p><p>启动本地驱动程序，Master 程序已经调试成功了</p><p><img src="/images/spark/spark-09.png" alt=""></p><p><img src="/images/spark/spark-08.png" alt=""></p><p>接下来，配置 Worker 远程调试。</p><p>同理配置 <code>SPARK_HOME/conf/spark-env.sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPARK_WORKER_OPTS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</span><br></pre></td></tr></table></figure><p>在 Worker.scala 打上断点</p><p><img src="/images/spark/spark-11.png" alt=""></p><p>客户端连接服务端</p><p><img src="/images/spark/spark-07.png" alt=""></p><p><img src="/images/spark/spark-06.png" alt=""></p><p>执行本地驱动程序，Worker 程序调试成功</p><p><img src="/images/spark/spark-09.png" alt=""></p><p><img src="/images/spark/spark-05.png" alt=""></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight java"><figcaption><span>WordCount.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"wordCount"</span>)</span><br><span class="line">                .setJars(<span class="keyword">new</span> String[]&#123;<span class="string">".//target//wordcount.jar"</span>&#125;)</span><br><span class="line">                .setMaster(<span class="string">"spark://192.168.2.5:7077"</span>);</span><br><span class="line">        JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line">        JavaRDD&lt;String&gt; input = sc.textFile(<span class="string">"/usr/local/spark-2.1.0-bin-hadoop2.7/README.md"</span>);</span><br><span class="line">        JavaRDD&lt;String&gt; words = input.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.asList(s.split(<span class="string">" "</span>)).iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JavaPairRDD&lt;Object, Object&gt; counts = words.mapToPair(<span class="keyword">new</span> PairFunction&lt;String, Object, Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;Object, Object&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;Object, Object&gt;(s, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).reduceByKey(<span class="keyword">new</span> Function2&lt;Object, Object, Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Object x, Object y)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Integer)x + (Integer)y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        counts.saveAsTextFile(<span class="string">"/tmp/wc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> spark 入门系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark 快速入门教程（二） - Self-Contained 应用程序</title>
      <link href="/spark-2/"/>
      <url>/spark-2/</url>
      
        <content type="html"><![CDATA[<p>如何使用独立应用程序(self-contained applications) 来使用Spark API， 实现一个单词计数小程序。</p><a id="more"></a><p>新建一个Maven项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate</span><br></pre></td></tr></table></figure><p>编辑MAVEN配置文件</p><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zengyilun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spark Hello Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- Spark dependency --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建驱动程序（含主函数的程序） 来实现单词技术的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"wordCount"</span>);</span><br><span class="line">        JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"plz input args[0](input-path) args[1](output-path)"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        JavaRDD&lt;String&gt; input = sc.textFile(args[<span class="number">0</span>]);</span><br><span class="line">        JavaRDD&lt;String&gt; words = input.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.asList(s.split(<span class="string">" "</span>)).iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        JavaPairRDD&lt;Object, Object&gt; counts = words.mapToPair(<span class="keyword">new</span> PairFunction&lt;String, Object, Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;Object, Object&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;Object, Object&gt;(s, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).reduceByKey(<span class="keyword">new</span> Function2&lt;Object, Object, Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Object x, Object y)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (Integer)x + (Integer)y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        counts.saveAsTextFile(args[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前的项目结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find .</span><br><span class="line">./pom.xml</span><br><span class="line">./src</span><br><span class="line">./src/main</span><br><span class="line">./src/main/java</span><br><span class="line">./src/main/java/WordCount.java</span><br></pre></td></tr></table></figure><p>构建项目， 使用 <code>./bin/spark-submit</code> 提交并执行项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mvn package</span><br><span class="line"></span><br><span class="line">[INFO] Building jar : &#123;..&#125;/&#123;..&#125;/target/spark-hello.jar</span><br><span class="line"></span><br><span class="line">$ SPARK_HOME/bin/spark-submit --class <span class="string">"WordCount"</span> target/spark-hello.jar SPARK_HOME/README.md /tmp/wc</span><br></pre></td></tr></table></figure><p>通过传入 Spark 目录下的README.md， Spark 统计单词结构将会输出在 /tmp/wc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ find /tmp/wc</span><br><span class="line">part-00000</span><br><span class="line">part-00001</span><br><span class="line">_SUCCESS</span><br><span class="line">$ cat /tmp/wc/_part-00000</span><br><span class="line">(package,1)</span><br><span class="line">(this,1)</span><br><span class="line">(Version<span class="string">"](http://spark.apache.org/docs/latest/building-spark.html#specifying-the-hadoop-version),1)</span></span><br><span class="line"><span class="string">(Because,1)</span></span><br><span class="line"><span class="string">(Python,2)</span></span><br><span class="line"><span class="string">(page](http://spark.apache.org/documentation.html).,1)</span></span><br><span class="line"><span class="string">(cluster.,1)</span></span><br><span class="line"><span class="string">(its,1)</span></span><br><span class="line"><span class="string">([run,1)</span></span><br><span class="line"><span class="string">(general,3)</span></span><br><span class="line"><span class="string">(have,1)</span></span><br><span class="line"><span class="string">(pre-built,1)</span></span><br><span class="line"><span class="string">(YARN,,1)</span></span><br><span class="line"><span class="string">([http://spark.apache.org/developer-tools.html](the,1)</span></span><br><span class="line"><span class="string">(changed,1)</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Spark 快速大数据分析》</li><li>[Spark 官方文档](<a href="http://spark.apache.org/docs/latest/" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> spark 入门系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark 快速入门教程（一） - Spark 体验</title>
      <link href="/spark-1/"/>
      <url>/spark-1/</url>
      
        <content type="html"><![CDATA[<p>Spark 入门教程, 下载与安装，Spark Shell 的使用。</p><a id="more"></a><h1 id="Spark-是什么"><a href="#Spark-是什么" class="headerlink" title="Spark 是什么"></a>Spark 是什么</h1><p>Spark 是一个用来实现快速而通用的<strong>集群计算平台</strong>。</p><p>相比 MapReduce 计算模型，Spark 的一个主要特点就是能够在内存中进行计算，因而更快，不过即使是必须在磁盘上进行的复杂方面，在速度方面比 MapReduce 更加高效。</p><p>Spark 所提供的接口非常丰富。除了提供基于 Python、 Java、 Scala、 R 和 SQL 的简单易用的API以及内建的丰富程序以外， Spark 还能和其他大数据工具密切配合使用。 例如，Spark 可以运行在 Hadoop 集群上，访问包括 Cassandra 在内的任意 Hadoop 数据源。</p><p>Spark 支持为各种不同的应用场景专门设计的高级组件，比如SQL和机器学习等。<br><img src="/images/spark/spark-01.png" alt=""></p><h1 id="Spark-下载与安装"><a href="#Spark-下载与安装" class="headerlink" title="Spark 下载与安装"></a>Spark 下载与安装</h1><p>Spark 现属于 apache 开源软件基金会，访问 <a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">http://spark.apache.org/downloads.html</a> 下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://d3kbcqa49mib13.cloudfront.net/spark-2.1.1-bin-hadoop2.7.tgz</span><br><span class="line">tar -xzf spark-2.1.1-bin-hadoop2.7.tgz</span><br></pre></td></tr></table></figure><h1 id="运行-Spark-例子和-Shell"><a href="#运行-Spark-例子和-Shell" class="headerlink" title="运行 Spark 例子和 Shell"></a>运行 Spark 例子和 Shell</h1><p>切换到 Spark 目录下，运行例子显示 Pi 的10位小数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/run-example SparkPi 10</span><br></pre></td></tr></table></figure><p>运行 Spark Shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-shell</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val lines = sc.textFile(<span class="string">"README.md"</span>) //读取 Spark 目录下的 README.md</span><br><span class="line">scala&gt; lines.count() //返回文档总行数</span><br><span class="line">scala&gt; lines.first() //返回文档第一行</span><br></pre></td></tr></table></figure><p>退出 Shell <code>Ctrl + D</code></p><p>变量 lines 是一个RDD，是从你的电脑上的本地文件读入的文本文件创建出来的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Spark 快速大数据分析》</li><li><a href="http://spark.apache.org/docs/latest/" target="_blank" rel="noopener">Spark 官方文档</a></li></ul><p>下一篇，将介绍如何使用独立Java程序来操作RDD。</p>]]></content>
      
      
      <categories>
          
          <category> spark 入门系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>书籍推荐</title>
      <link href="/books-recomm/"/>
      <url>/books-recomm/</url>
      
        <content type="html"><![CDATA[<p>Allyn 的书单， 包含知识的入门和进阶。</p><h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><ul><li>《java 核心技术 卷I》<br>作为0基础编程，Java初学者读物</li><li>《java 核心技术 卷II》 </li><li>《java 编程思想》(thinking in java)</li><li>《Effective Java》 </li></ul><h1 id="Java-框架"><a href="#Java-框架" class="headerlink" title="Java 框架"></a>Java 框架</h1><ul><li>《Spring in Action》(Spring 实战)</li></ul><h1 id="Java-高级"><a href="#Java-高级" class="headerlink" title="Java 高级"></a>Java 高级</h1><ul><li>《深入理解 java虚拟机》</li><li>《java并发编程实战》</li></ul><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ul><li>《JavaScript 权威指南》</li><li>《CSS 权威指南》</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li>《高性能 MySQL》<br>作为一个开发人员必须知道这些。。。</li></ul><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><ul><li>《Spark 快速大数据分析》<br>这本书真的是快速入门，不过具体细节还是要查官方文档[spark offical site], 比如搭建集群没有讲很清楚。</li></ul><h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><ul><li>《Selenium 实战基于 python》 讲的很基础，如果是程序猿看这个很轻松</li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><ul><li>《Python 基础编程》 Python 入门书籍！</li></ul><h1 id="C-和-C"><a href="#C-和-C" class="headerlink" title="C# 和 C++"></a>C# 和 C++</h1><ul><li>《精通C#》<br>这本书作为入门是很不错的，适合有编程基础的看，虽然超级厚</li><li>《CLR via C#》</li><li>《windows via C++》 </li></ul><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><ul><li>《编码》 计算机是怎么来的，对理解计算机的工作原理很有帮助</li><li>《unix network programming》 理解网络必备，所有网络编程都是基于这个原理来的。</li></ul><h1 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li>《Pro.Git》 初学者只推荐这本，《Git权威指南》虽然写的很不错，不过对于刚学习Git的同学太难理解。</li></ul><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><ul><li>《Maven实战》 只看这本书足以，所有Maven特性都写了。</li></ul><h1 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h1><ul><li>《完全图解猫的心理》 林乐毅 – 养猫必备</li></ul><p>持续更新中。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java程序设计</title>
      <link href="/java-tutorial/"/>
      <url>/java-tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序设计环境"><a href="#Java程序设计环境" class="headerlink" title="Java程序设计环境"></a>Java程序设计环境</h1><p>Jre(java runtime environment): 是一个虚拟机，类似.net的clr，里面有Java内存模型，基于自动内存托管堆，集成了各种分代GC回收算法，以及类子节码解析器以及各种JIT等等；</p><a id="more"></a><p>Jdk(java development kit): 包括Jre，并且提供了Java代码到类子节码文件的编译器，以及线程/内存/虚拟机的诊断工具等等；</p><p>SWING/AWT: Java桌面端程序开发组件，可以理解为.net的WPF一套的技术，这套技术没有WPF普及，这个原因还是因为客户机基本都是windows系统，.net和windows集成更好都是一家公司，另外WPF的表现力更好；</p><p>Applet: 可以运行在网页上面的Java小程序，可以理解为.net的Silverlight那套的技术，由于Flash以及Html5，该技术宿命也和SL一样走向了衰亡；</p><p>Jdk 的安装：</p><p>下载jdk <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>安装</p><p>如果是使用的压缩包的安装方式， 需要配置环境变量JAVA_HOME=/jdk/path/, PATH=.;%PATH%;%JAVA_HOME%/bin;</p><p>win+R -&gt; cmd 输入java</p><h1 id="Java基本的程序设计"><a href="#Java基本的程序设计" class="headerlink" title="Java基本的程序设计"></a>Java基本的程序设计</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p><img src="/images/hello.png" alt="hello"></p><p>保存为HelloWorld.java<br>编译javac HelloWorld.java  – 生成 HelloWorld.class<br>运行java HelloWorld<br>打印输出<br>Hello, World  </p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="基础数据类型："><a href="#基础数据类型：" class="headerlink" title="基础数据类型："></a>基础数据类型：</h4><p>int/short/long/byte/float/double/char/boolean/pointer</p><p>int 4 bytes =  2 ^ 8 ^ 4 / 2 ~ 2 ^ 8 ^ 4 / 2 - 1 = 2 ^ 32 / 2 ~ 0 ~ 2 ^ 32 / 2 - 1 = 2,147,483, 647</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">范围</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">4 bytes</td><td style="text-align:center">-2,147,483,648 to 2,147,483, 647 (just over 2 billion)</td><td style="text-align:center">The wrapper type is Integer. Use BigInteger for arbitrary precision integers</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2 bytes</td><td style="text-align:center">-32,768 to 32,767</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8 bytes</td><td style="text-align:center">-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td><td style="text-align:center">Literals end with L (e.g. 1L)</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">1 byte</td><td style="text-align:center">-128 to 127</td><td style="text-align:center">Note that the range is not 0 … 255</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4 bytes</td><td style="text-align:center">approximately -3.40282347E+38F (6-7 significant decimal digits)</td><td style="text-align:center">Literals end with F (e.g. 0.5F)</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8 bytes</td><td style="text-align:center">approximately -1.79769313486231570E+308 (15 significant decimal digits)</td><td style="text-align:center">Use BigDecimal for arbitrary precision floating-point numbers</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2 bytes</td><td style="text-align:center">\u0000 to \uFFFF</td><td style="text-align:center">The wrapper type is Character. Unicode characters &gt; U+FFFF require two char values</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"></td><td style="text-align:center">true or false</td></tr></tbody></table><p>java 中没有无符号类型的数值类型。</p><h4 id="类型转换-："><a href="#类型转换-：" class="headerlink" title="类型转换 ："></a>类型转换 ：</h4><p><em>虚线代表精度丢失</em>。<br><img src="/images/type-conversion.png" alt="type-conversion"></p><h4 id="包装数据类型："><a href="#包装数据类型：" class="headerlink" title="包装数据类型："></a>包装数据类型：</h4><p>Integer/Long/Short/Byte/Float/Double/Character/Number</p><pre><code>Integer a = 5; -&gt; Integer a = new Integer(5);int b = Integer.parseInt(&quot;5&quot;); -&gt; Integer b = Integer.parseInt(&quot;5&quot;);</code></pre><p>包装类可以为空，包装类有一些工具可以将其他类型的变量转换。 </p><h4 id="原子数据类型："><a href="#原子数据类型：" class="headerlink" title="原子数据类型："></a>原子数据类型：</h4><p>AtomicInteger/AtomicLong/AtomicBoolean 线程安全版的基础包装数据类型，实现方式并非同步锁，机器语言级别的实现方式，比同步锁有更高的效率。</p><p>比如AtomicInteger 的 .incrementAndGet() 可以安全的自增长 而省去了 同步。</p><h4 id="特殊数据类型："><a href="#特殊数据类型：" class="headerlink" title="特殊数据类型："></a>特殊数据类型：</h4><p>BigDecimal/BigInteger</p><pre><code>double d = 29.0 * 0.01;System.out.println(d);System.out.println((int) (d * 100));输出:    0.29    28double a = 0.2 + 0.4;System.out.println(a);输出：    0.6000000000000001</code></pre><p>IEEE 754</p><p>IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。</p><p><img src="/images/float.gif" alt="float"></p><p>符号位 指数 尾数</p><p>BigDecimal 比float, double 有更大的精度（无限精度）.<br>BigInterger 当整数超过Long大小时(2^64/2-1)，可以用这个。</p><p>如浮点类型一样， BigDecimal 也有一些令人奇怪的行为。尤其在使用 equals() 方法来检测数值之间是否相等时要小心。 equals() 方法认为，两个表示同一个数但换算值不同（例如， 100.00 和 100.000 ）的 BigDecimal 值是不相等的。然而， compareTo() 方法会认为这两个数是相等的，所以在从数值上比较两个 BigDecimal 值时，应该使用 compareTo() 而不是 equals() 。</p><p>Java中的浮点数参考文献：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp0114/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp0114/</a></p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>类 - 首字母大小驼峰  class CamelCase{}<br>接口 - 与类相同 interface USBInterface {}<br>变量 - 首字母小写驼峰  int camelCase = 10<br>常量 - 全大写，下划线分割 public static final String CONSTANT_STRING = “VALUE”<br>方法 - 首字母小写驼峰 void doSomething(){}<br>包 - 全小写，公司域名倒写 com.sunyuki.Test   </p><p>官方文档 <a href="http://www.oracle.com/technetwork/java/codeconventions-135099.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/codeconventions-135099.html</a></p><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><p>变量:</p><pre><code>double salary;int vocationDays;long earthPopluation;salary = 20;int middle；for(int i = 0;i &lt; 10; i++){}</code></pre><p>常量:</p><pre><code>final double cannotChange;</code></pre><p>数组：<br>    int a[] = {1, 2, 3};<br>    int[] a = new int[3];<br>    String[] b = new String[]{“a”, “b”, “c”};</p><p>JAVA可以将变量的声明放任意地方。 </p><h2 id="运算符（Operator"><a href="#运算符（Operator" class="headerlink" title="运算符（Operator)"></a>运算符（Operator)</h2><p>基础运算符 + - * / % =<br>条件运算符 &amp;&amp; ||<br>位运算符 &amp; | ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; &lt;&lt;&lt;<br>自增运算符 ++, –<br>三元运算符 ?:<br>关系运算符 == != &gt; &lt;= &lt;<br>类型比较运算符 instanceof</p><p>数学函数与常量</p><ul><li>Math.sin</li><li>Math.cos</li><li>Math.tan</li><li>Math.atan</li><li>Math.log</li><li><p>Math.log10</p></li><li><p>Math.PI</p></li><li>Math.E</li></ul><p>优先级：  </p><ul><li>[] . () (method call)    Left to right      </li><li>! ~ ++ – + (unary) - (unary) () (cast) new     </li><li><ul><li>/ %          </li></ul></li><li>&lt;&lt; &gt;&gt; &gt;&gt;&gt;      </li><li>&lt; &lt;= &gt; &gt;= instanceof      </li><li>== !=      </li><li>&amp;      </li><li>^            </li><li>|          </li><li>&amp;&amp;             </li><li>||        </li><li>?:       </li><li>= += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=    </li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符: ‘A’   转ascii: （int)’A’<br>字符串: String a = “hello, world”<br>字符串拼接: “A” + “B”  </p><p>字符串的一些方法:</p><ul><li>charAt()  </li><li>length()</li><li>substring(0, length) 左闭右开</li><li>startsWith()</li><li>endsWith()</li><li>indexOf()</li><li>concat()</li><li>replace()</li><li>replaceAll() 正则</li><li>trim()</li><li>toUpperCase();</li></ul><p>String 是只读的，String 类的方法都是创建了一个新的String, 并没有改变原来的。</p><pre><code>String upper = &quot;test&quot;.toUpperCase();</code></pre><p>再比如</p><pre><code>String s = &quot;abcd&quot;;s = s.concat(&quot;ef&quot;);</code></pre><p><img src="/images/string-readonly.jpeg" alt="readonly"></p><h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h4><pre><code>String a = &quot;test&quot;;String b = &quot;test&quot;;String c = new String(&quot;test&quot;);a == b -&gt; trueb == c -&gt; falsea.equals(b) -&gt; trueb.equals(c) -&gt; true</code></pre><p>== ： 测试内存地址相等<br>.equals : 逻辑相等</p><p>a和b都是从常量池中取的数据， 而new String是新分配一个内存地址</p><pre><code>// These two have the same valuenew String(&quot;test&quot;).equals(&quot;test&quot;) // --&gt; true // ... but they are not the same objectnew String(&quot;test&quot;) == &quot;test&quot; // --&gt; false // ... neither are thesenew String(&quot;test&quot;) == new String(&quot;test&quot;) // --&gt; false // ... but these are because literals are interned by // the compiler and thus refer to the same object&quot;test&quot; == &quot;test&quot; // --&gt; true String#equals:@Overridepublic boolean equals(Object anObject) {    if (this == anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString = (String)anObject;        int n = value.length;        if (n == anotherString.value.length) {            char v1[] = value;            char v2[] = anotherString.value;            int i = 0;            while (n-- != 0) {                if (v1[i] != v2[i])                    return false;                i++;            }            return true;        }    }    return false;}</code></pre><p>equals 可以使用equals方法检测两个字符串是否相等。</p><h4 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h4><p>普通拼接</p><pre><code>String str = &quot;&quot;;str += &quot;abc&quot;; -&gt; new StringBuider().append(&quot;abc&quot;);System.out.println(str);</code></pre><p>循环时</p><pre><code>String res = &quot;&quot;;for(int i = 0; i &lt; fields.length; i++){    res += fields[i];  -&gt; res = new StringBuilder().append(fields[i]);}return res;StringBuilder sb = new StringBuilder();for(int i = 0; i &lt; fields.length; i++){    sb.append(fields[i]);}return sb.toString();</code></pre><p>StringBuilder 中不正确的用法</p><pre><code>new StringBuilder().append(&quot;a&quot; + &quot;b&quot;); -&gt; new StringBuilder(new StringBuilder(&quot;a&quot;).append(&quot;b&quot;).toString());</code></pre><p>在循环中， 使用StringBuilder 而不是字符串的拼接更有效率、更节省内存。</p><p>StringBuffer 是 StringBuilder 的线程安全版。</p><p>String的Format(这里可以顺便提一下Java的可变参数)</p><p>格式化输出：</p><pre><code>String str = String.format(&quot;there is  only %s %d minutes&quot;, &quot;last&quot;, 10);System.out.format(&quot;there is  only %s %d minutes&quot;, &quot;last&quot;, 10)System.out.printf(&quot;there is  only %s %d minutes&quot;, &quot;last&quot;, 10)</code></pre><p>格式化说明符  </p><p>常见转换符 d、x、o、f、s、c、b、h（哈希）、%、n（平台独立换行符）</p><p>没有ld、lld、lf 这些。</p><p>Java函数可变参数：</p><pre><code>public void printf(String format, String... specification){    String arg0 = specification[0];    ...    System.out.print(arg0);}</code></pre><p>正则表达式:</p><pre><code>String[] words = str.split(&quot;\\s+&quot;); 切割---String newWords = str.replaceAll(&quot;[0-9]+&quot;,&quot;#&quot;); 替换--Pattern pattern = Pattern.compile(&quot;[0-9]+&quot;);Matcher matcher = pattern.matcher(str); while (matcher.find()) {  process(str.substring(matcher.start(), matcher.end())); } 获取---Pattern pattern = Pattern.compile(&quot;[0-9]+(\\w)&quot;);Matcher matcher = pattern.matcher(str); while (matcher.find()) {  process(str.group(1)); } 获取（组）</code></pre><h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>一对花括号就是一个块，块决定了变量的作用域。</p><p>局部变量与全局变量：</p><pre><code>public static void main(String args[]){    int n;    ..    {        int b;        int k;    }}</code></pre><p>Java 中局部变量不允许覆盖全局变量！</p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><pre><code>public class Test{    int    a; //默认值0    boolean c;//false    char d; //null    public void test(){        int b;//是一个垃圾数，但Java强制要求必须初始化，不必担心。        System.out.println(b); // -- 报错， 因为没有初始化    }}</code></pre><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><pre><code>if(a &gt;= b){    ..}else if(a &gt;= c){    ..}else{    ..}switch(choice){    case 1:        ..        break;    case 2:        ..        break;    default:        //other input        break;}</code></pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>do while/while do/for/foreach</p><pre><code>int i = 0;while(i &lt; 10){...i++}do{    ...    i++;}while(i &lt; 10);for(int i = 0;i &lt; 10;i++){    ...}String[] strs = new String()[];List list = new ArrayList(); for(Object item : list){ -&gt; for each 其实是 使用了实现了Iterable接口的类的iterator方法。}Iterator it = list.iterator();while(it.hasNext){    process(it.next());}</code></pre><h4 id="中断循环"><a href="#中断循环" class="headerlink" title="中断循环"></a>中断循环</h4><pre><code>while(it.hasNext()){    if(it.next() == accuary){        ...        break;    }}while(it.hasNext()){    if(it.next() == badResult){        ...        countinue;    }    ...}A:while(it.hasNext()){    ...    for(int i = 0;i &lt; size;i++){        if(isFind){            break A;            }    }}</code></pre><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><pre><code>public class A {    private int i; -- 成员变量(member field)    private static int j; -- 静态成员变量    public static final CONSTANT_A = &quot;HELLO&quot; -- 类常量    public static void main(){String[] args[]){} -- 类函数、静态函数    public A(){} -- 默认构造函数，如果没有任何构造函数 就有这个    public A(int i){ -- 带参数的构造函数        this.i = i;    }    class B{        private int x;                ...    }}</code></pre><h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><pre><code>public interface A {    int a = 0; -&gt; public final int a;   -- 接口只能是常量     void method1(); -&gt; public abstract void method1(); -- 默认就是抽象方法}public abstract class A {    public abstract void method1();}</code></pre><p>接口与抽象类并不能实例化。</p><h4 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h4><pre><code>A a = new A();</code></pre><h4 id="继承已有一个类"><a href="#继承已有一个类" class="headerlink" title="继承已有一个类"></a>继承已有一个类</h4><pre><code>public class B(){    public B(){        System.out.println(&quot;B 默认构造函数&quot;);    }    public B(String b){        System.out.println(&quot;b 带参构造函数&quot;);    }}class A extends B {    public A(){        //super(); -- 如果没写， 将默认添加    }    public A(String a){        //super(); -- 如果没写， 将默认添加        super(a); -- 只能调用其中一个超类的构造函数        System.out.println(a + &quot; 带参构造函数&quot;);    }}A a = new A();A a2 = new A(&quot;a&quot;);打印结果：    B 默认构造函数    b 带参构造函数    a 带参构造函数</code></pre><h4 id="Object-类-所有类的超类"><a href="#Object-类-所有类的超类" class="headerlink" title="Object 类 - 所有类的超类"></a>Object 类 - 所有类的超类</h4><pre><code>class Employee -&gt; class Employee extends Object</code></pre><p>Object 类的方法</p><pre><code>class Object{    public native int hashCode();    public final native Class&lt;?&gt; getClass();    public boolean equals(Object obj) { return (this == obj);}    public String toString() {        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());    }}</code></pre><p><strong>equals 方法</strong></p><p>用于检测一个对象是否等于另一个对象。</p><p><strong>hashCode 方法</strong></p><p>散列码。由对象导出的整型值。</p><ul><li>如果两个对象相等(equal)，那么他们一定有相同的哈希值。</li><li>如果两个对象的哈希值相同，但他们未必相等(equal)。</li></ul><p><strong>toString 方法</strong></p><p>对象序列化为字符串。默认为 类名+@+哈希值</p><p>方法覆盖与方法重载</p><pre><code>public class B(){ public void method1(){} }public class A(){    //覆盖    @Override    public void method1(){}    //重载    public void method1(String a){}}</code></pre><p>子类构造函数始终要调用父类构造函数。</p><h4 id="实现抽象类和接口"><a href="#实现抽象类和接口" class="headerlink" title="实现抽象类和接口"></a>实现抽象类和接口</h4><pre><code>public class A extends B {} -- 继承抽象类public class A implements B {} -- 实现接口</code></pre><h4 id="初始化块-静态初始化块"><a href="#初始化块-静态初始化块" class="headerlink" title="初始化块/静态初始化块"></a>初始化块/静态初始化块</h4><pre><code>public class A{    {        System.out.println(&quot;初始化块&quot;);    }    static{        System.out.println(&quot;静态初始化块&quot;);    }    public A(){        System.out.println(&quot;构造函数&quot;);    }    ..}打印结果：    静态初始化块    初始化块    构造函数</code></pre><h4 id="final在Java语法中的各种作用"><a href="#final在Java语法中的各种作用" class="headerlink" title="final在Java语法中的各种作用"></a>final在Java语法中的各种作用</h4><pre><code>final public class A{ -- 不能被继承    public static final String FIELD_NAME = &quot;HELLO&quot;; --不能被改变    public final void method1(){        final int a = 0; --不能被改变    }}</code></pre><h4 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h4><p>Java允许使用包将类组织起来，类似于命名空间。</p><p>类的导入，</p><pre><code>java.util.Date today = new java.util.Date();</code></pre><p>显然这很麻烦，可以使用import语句导入一个特定的类或者完成的包：</p><pre><code>import java.util.Date;import some.package.*;</code></pre><h4 id="Java中各种访问级别区别-default-private-public-protected"><a href="#Java中各种访问级别区别-default-private-public-protected" class="headerlink" title="Java中各种访问级别区别(default/private/public/protected)"></a>Java中各种访问级别区别(default/private/public/protected)</h4><p><img src="/images/access-level.png" alt="access-level"></p><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><pre><code>public class A{    private int i = 0;    public class B{        public void test(){            int i = A.this.i; --使用外部类的实例的成员变量            ...        }    }}</code></pre><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><pre><code>public class A{    private int i = 0;    public static class B{        public void test(){        }    }}</code></pre><h4 id="内部类的实例化"><a href="#内部类的实例化" class="headerlink" title="内部类的实例化"></a>内部类的实例化</h4><pre><code>A a = new A();A.B b = a.new B();A.B ab = new A.B();</code></pre><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><pre><code>A.B ab = a.new B(){    @Override    public void test(){        supper.test();    }}</code></pre><h4 id="C-中委托在JAVA中的实现方法-Deletegate-Callback，Hook"><a href="#C-中委托在JAVA中的实现方法-Deletegate-Callback，Hook" class="headerlink" title="C# 中委托在JAVA中的实现方法 - Deletegate, Callback，Hook"></a>C# 中委托在JAVA中的实现方法 - Deletegate, Callback，Hook</h4><pre><code>public class A{    public interface Listener{        void onClick();    }    public void invoked(Listener listener){        ...        listener.onClick();        ...    }}A a = new A();a.invoked(new Listener(){    @Override    public void onClick(){        System.out.println(&quot;onClick&quot;);    }});</code></pre><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><pre><code>public enum WEEK{    MONDAY, TUESDAY} public enum WEEK{    MONDAY(&quot;MON&quot;), TUESDAY(&quot;TUE&quot;)    private String value;    public WEEK(String value){        this.value = value;    }    public String getValue(){        return this.value    }}</code></pre><p>枚举类型其实是 继承于Enum的类。</p><pre><code>public enum WEEK{    MONDAY, TUESDAY} 类似于 -- （当然，并不允许直接继承Enum)public class WEEK extends Enum{    public static final Enum MONDAY = new Enum(&quot;MONDAY&quot;, 0);    public static final Enum TUESDAY = new Enum(&quot;TUESDAY&quot;, 1);    Enum(String name, int ordinal) {        super(name, ordinal);    }}</code></pre><h2 id="常用的包与类"><a href="#常用的包与类" class="headerlink" title="常用的包与类"></a>常用的包与类</h2><pre><code>java.applet    Applets (Java programs that run inside a web page)  java.awt    Graphics and graphical user interfaces  java.beans    Support for JavaBeans components (classes wi th properties and event listeners)  java.io    Input and output  java.lang    Language support java.math    Arbitrary-precision numbersjava.net    Networkingjava.nio    &quot;New&quot; (memory-mapped) I/Ojava.rmi    Remote method invocationsjava.security    Security supportjava.sql    Database supportjava.text    Internationalized formatting of text and numbersjava.time    Dates, time, duration, time zones, etc.java.util    Utilities (including data structures, concurrency, regular expressions, and logging)</code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><em>这里简单介绍一下如何利用反射动态创建对象，并写利用反射动态获取私有域，静态域，方法调用等</em></p><pre><code>package com.sunyuki;public class A {    private String a = &quot;a&quot;;    public static final String B = &quot;B&quot;;    public void method1(){ System.out.println(&quot;method1&quot;); }    public String setA(String a){ return this.a = a; }}Class aClass = Class.forName(&quot;com.sunyuki.A&quot;);A a = (A)aClass.newInstance();a.setA(&quot;aaa&quot;);Fields[] fs = a.getDeclaredFields();for(Field f : fs){    f.setAccessible(true);    Object o = f.get(a);    System.out.println(o);}Method method1 = aClass.getMethod(&quot;method1&quot;);System.out.println(method1.invoke(a, null));打印出：    aaa    B    method1</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常</p><p><img src="/images/exception.jpeg" alt="exceptions"></p><pre><code>Throwable\--                    \-- Exception                     \-- RuntimeException</code></pre><p>异常 – 如果遇到了无法处理的情况，那么Java的方法可以抛出一个异常，例如删除一个文件，文件不存在，试图处理删除文件的代码会抛出IOException异常。</p><p>Java中异常分为两类 – 声明式异常和运行时异常，顾名思义，声明式异常需要在代码中显式的处理（抛出或捕获），而运行时异常需要程序在运行时才会知道。</p><p>声明异常</p><pre><code>public method1 throws IOException {    //delete files...    new File(&quot;c:\\abc.txt&quot;).delete();}</code></pre><p>运行异常</p><pre><code>继承RuntimeException就不需要在方法上显式声明。（如NullPointerException)</code></pre><p>异常处理(异常捕获)</p><pre><code>BufferedReader br = null;try{    br = new BufferdReader(..);    ...}catch(Excpetion e){    ...}finally{    ...    if(br != null){        br.close();    }}</code></pre><p>自定义异常</p><pre><code>public class ApiException extends Exception{    public ApiException(){}    public ApiException(String message){        super(message);    }}public class ApiRuntimeException extends RuntimeException{    public ApiException(){}    public ApiException(String message){        super(message);    }}</code></pre><p>抛出异常 - 处理异常 完整流程</p><pre><code>Class Biz{    private Dao dao;    public void save(Model model) throws ApiException(){        if(dao.findExisted(model.getId())){            throw new ApiException(&quot;已存在&quot;);        }        dao.insert(model);    }}Class FrontEndController{    public ResultModel save(Model model){        ResultModel res = new ResultModel();        res.setSuccess(true);        res.setMessage(&quot;成功&quot;);        try{            biz.save(model);        }catch(ApiException e){            logger.error(e);            res.setSuccess(false);            res.setMessage(e.getMessage());        }        return res;    }}</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>数据结构：hash/array/tree/link</p><pre><code>Collection    \_ Set                    \_ List                                \_HashSet \_TreeSet        \_LinkedList \_ArrayList</code></pre><h4 id="List-接口-队列-先进先出）。"><a href="#List-接口-队列-先进先出）。" class="headerlink" title="List 接口 (队列 - 先进先出）。"></a>List 接口 (队列 - 先进先出）。</h4><p>ArrayList - 内部由固定数组实现，所以请的内存是连续的，遍历这个集合就很快，如果添加元素后，元素个数大于数组大小，就会新申请一个更大的数组，新增就特别慢，删除是用后一个元素覆盖前一个元素。</p><pre><code>Object o = new Object();List list = new ArrayList();list.add(o);for(int i = 0;i &lt; list.size();i++){    proccess(list.get(i));}list.remove(i-1);</code></pre><p>LinkedList - 链表，由于是用一个一个的不连续的内存 通过前后指针链接起来的，遍历这个集合或者获取其中某一个值就很慢，但是删除和新增特别快，因为只需要把前一个节点的指针指向后一个节点的指针即可。</p><pre><code>Object o = new Object();List list = new LinkedList();list.add(o);for(int i = 0;i &lt; list.size();i++){    process(list.get(i));}list.remove(i-1);</code></pre><h4 id="Set-集-不在意顺序（没有下标），不允许有相同的元素（如何判断是不是相同：调用equals方法…）"><a href="#Set-集-不在意顺序（没有下标），不允许有相同的元素（如何判断是不是相同：调用equals方法…）" class="headerlink" title="Set 集(不在意顺序（没有下标），不允许有相同的元素（如何判断是不是相同：调用equals方法…）)"></a>Set 集(不在意顺序（没有下标），不允许有相同的元素（如何判断是不是相同：调用equals方法…）)</h4><p>HashSet 无序的</p><pre><code>Set set = new HashSet();set.add(new Object());for(Object o : set){    process(o);            }Iterator iterator = set.iterator();while(iterator.hasNext()){    process(set.next());}</code></pre><p>TreeSet 有序的</p><pre><code>Set set = new TreeSet(new Comparator() {    public int compare(Object o1, Object o2) {        return ((A)o1).getA() - ((A)o2).getA();    }});set.add(new Object());for(Object o : set){    process(o);            }Iterator iterator = set.iterator();while(iterator.hasNext()){    process(set.next());}</code></pre><h4 id="Comparable-与-Comparator"><a href="#Comparable-与-Comparator" class="headerlink" title="Comparable 与 Comparator"></a>Comparable 与 Comparator</h4><p>Comparable </p><pre><code>class Student implements Comparable&lt;Student&gt;{    private String number;    private String name;    @Override public int compareTo(Student stu){        return number.compareTo(stu.number);      }} </code></pre><p>什么时候用Comparable与Comparator, Comparator只是作为临时的比较策略， 最好使用Comparable，这样的话不论在哪里使用到了排序，都可以不用再写Comparator，不过已经封装好的类，没有实现Comparable接口，这时可以使用Comparator。</p><p>集合类型：list/set/map</p><pre><code>Map    \_HashMap \_TreeMap</code></pre><p>Map（字典，图）</p><p>HashMap 无序， 同一个键 只能有一个值</p><pre><code>  Map map = new HashMap();Set keySet = map.keySet();for(Object key : keySet){    Object value = map.get(key);}map.put(&quot;key&quot;, &quot;value&quot;);</code></pre><p>TreeMap 有序</p><pre><code>Map map = new TreeMap(new Comparator() {    public int compare(Object o1, Object o2) {        return ((A)o1).getA() - ((A)o2).getA();    }}); Set keySet = map.keySet();for(Object key : keySet){    Object value = map.get(key);}map.put(&quot;key&quot;, &quot;value&quot;);</code></pre><p>collection 与 collections 的区别</p><p><img src="/images/collections.jpeg" alt="coll"></p><p>线程安全与不安全</p><p>ArrayList - Vector</p><p>Stack 先进后出</p><p>HashMap - HashTable</p><p>Iterator - Enumeration</p><p><em>基于这3个维度来介绍Java中不同集合</em></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>如果应用泛型</p><p><em>泛型 - 旨在减少错误和增加可读性</em></p><pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();for(String str : list){    process(str);}List list = new ArrayList();for(Object o : list){    process((String)o);}</code></pre><p>定义泛型</p><pre><code>public class Pair&lt;T&gt;{    private T first;    public Pair(T first, T second){}    public T getFirst(){return first};}</code></pre><p>泛型方法</p><pre><code>public class Pair{    public static &lt;T&gt; T getMiddle(T... a){        return a[a.length / 2];        }    }} String middle = Pair.getMiddle(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code></pre><p>如果应用通配符</p><pre><code>public static void print(Pair&lt;? extends Employee&gt; pair){}public static void print(Pair&lt;? super Employee&gt; pair){}public static void print(Pair&lt;?&gt; pair){}</code></pre><p>为什么说Java相对于C#是假泛型</p><p>Java 中的泛型在编译后实际上还是使用的强制转换。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>定义线程与运行</p><pre><code>public class ThreadA implements Runnable{  -- 或者继承Thread    public void run() {        while(true) {            System.out.println(&quot;run a&quot;);            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}public class Main {    public static void main(String[] args) {        ThreadA threadA = new ThreadA();        new Thread(threadA).start();    }}</code></pre><p>中断线程  - 线程中断后 只是给线程一个警告，并不一定要结束线程。<br>Thread.currentThread().intercept();  </p><p>线程中断测试<br>Thread.intercepted(); – 会清除中断状态(Thread.sleep也会清除中断)<br>Thread.currentThread().isIntercepted(); – 不会清除中断状态  </p><p>线程状态</p><p>6大状态</p><ul><li>New 新建</li><li>Runnable 可运行</li><li>Blocked 被阻塞</li><li>Waiting 等待</li><li>Time waiting 计时等待</li><li>Terminated 被终止</li></ul><p><code>new Thread</code> ，这时他的状态为 <em>新建</em>， 还没有运行， 当然还有一些准备工作要做。<br><code>.start()</code>， 线程处于 <em>可运行</em> 状态。 一个在 <em>可运行</em> 状态的线程也可能还没运行，这取决于操作系统给线程提供运行的时间。<br>当线程处于<em>被阻塞</em> 或者 <em>等待</em>，它不运行任何代码且占用最少的资源，等待线程调度器重新激活它。</p><ul><li><p>当线程试图获取一个内部的对象锁，而该锁由其他线程使用，则该线程处于<em>被阻塞</em>状态，当其他线程释放锁，并且线程调度器允许本线程持有他的时候，该线程变成非阻塞状态</p></li><li><p>当线程等待另一个线程通知线程调度器一个条件时，它自己进入<em>等待</em>状态。在Java中调用<code>Object.wait</code>或者<code>Object.join</code>方法，或是等待<code>java.util.concurrent</code>库中的Lock或Condition时，就会进入这种情况。<em>等待</em>和<em>被阻塞</em>是不同的。</p></li><li><p>有几个方法有一个超时参数，调用他们导致线程进入<code>计时等待</code>状态。这个状态将一直保存到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep或Object.wait，Thread.join,Lock.tryLock以及Condition.await的计时版。</p></li></ul><p>状态的转换 - 当一个线程被阻塞或等待（或终止），另一个线程被调度为运行状态。当一个线程被重新激活（例如超时期满或者成功获得了一个锁），调度器检查是否有比当前运行线程更高的优先级，如果是这样，调度器从当前运行线程中挑选一个，剥夺其运行权，选择一个新的线程运行。</p><p>被终止的线程</p><p>线程有两个原因死亡</p><ul><li>run方法正常退出而死亡</li><li>因为一个没有捕获的异常终止了run方法而意外死亡</li></ul><p>特别是，可以调用线程的stop方法，该方法抛出TreadDeath错误对象，由此杀死线程。但是这个方法已过时。</p><p><img src="/images/thread.png" alt="thread"></p><p>Thread</p><ul><li>void join() 等待终止指定的线程</li><li>void join(long millis) 等待指定的线程死亡或者经过的毫秒数</li><li>Thread.State getState() (6大状态之一）</li><li>void stop() <strong>已过时的方法</strong>，停止线程</li><li>void suspend() 暂停线程的运行（挂起），<strong>已过时</strong>。</li><li>void resume() 恢复挂起的线程，<strong>已过时</strong>。</li></ul><p>线程优先级</p><p>通过<code>.setPriority</code>来设置线程的优先级。</p><ul><li>void setPriorty(int newPriorty) 设置优先级</li><li>static int MIN_PRIORITY 最小优先级1</li><li>static int MAX_PRIORITY 最大优先级10</li><li>static int NORM_PRIORITY 默认优先级5</li><li>static void yield() 使当前线程处于让步状态，如果有其他可运行线程与此线程有同样高的优先级，那么另外一个线程会先调度。 </li></ul><p>用户线程与守护线程</p><p>t.setDaemon(true)</p><p>守护线程的唯一用途就是为其他线程服务。当只剩下守护线程时，他就退出了。守护线程应该永远不去访问固有资源，如文件，数据库，因为可能随时在操作的时候中断。</p><p>线程异常处理</p><p>线程run()方法是不运行抛出申明式异常的，如果有RuntimeException或Error抛出，不必使用try catch 捕获，可以使用Thread.UncaughtExceptionHandler来处理线程结束前没有捕获到的异常</p><pre><code>public class ThreadB extends Thread implements Thread.UncaughtExceptionHandler {public void run() {    while (true) {        System.out.println(&quot;rush b&quot;);        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        this.stop(); //这个方法已经过时，不要使用。这里只是抛出异常的作用。    }}}ThreadB threadB = new ThreadB();threadB.start();threadB.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {    public void uncaughtException(Thread t, Throwable e) {        e.printStackTrace();        //log.error(&quot;thread exit&quot;);    }});输出    rush b    java.lang.ThreadDeath        at java.lang.Thread.stop(Thread.java:850)        at course.thread.ThreadB.run(ThreadB.java:17)</code></pre><p>也可以使用Thread.setDefaultUncaughtExceptionHandler来为所有线程指定线程异常处理器。</p><p>线程安全（同步）</p><pre><code>public class Ticket {public static int total = 100;static class Employee extends Thread {    @Override    public void run() {        while (true) {            try {                if (total &gt; 0) {                    Thread.sleep(10);                    total -= 1;                    System.out.printf(&quot;%s sold %d, remain %d %n&quot;, Thread.currentThread().getName(), 1, total);                } else {                    return;                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}public static void main(String[] args) {        for (int i = 0; i &lt; 10; i++) {            new Employee().start();        }    }}</code></pre><p>卖票程序.</p><p>线程安全的一些基本概念：</p><blockquote><p>线程的安全性的定义：当多个线程访问某个类时，这个类都始终表现出正确的行为，那么这个类就被认为是线程安全的。  </p><p>无状态对象：既不包含任何域，也不包含任何对其他类中域的引用（也就是不共享变量）。无状态对象一定是线程安全的。</p><p>原子性：不可分割。</p><p>竞争（竞态）条件：由于不恰当的执行顺序导致不正确的结果。</p></blockquote><p>竞争条件的一些情况</p><ul><li>先检查后执行</li><li>读取-修改-写入</li></ul><p>在无状态的类中添加一个状态，该状态由线程安全的对象来管理，那么这个类仍然是线程安全的。</p><p>线程池</p><pre><code>ExecutorService pool = Executors.newCachedThreadPool();Future&lt;Integer&gt; res = pool.submit(new Callable&lt;Integer&gt;() {        public Integer call() throws Exception {            return 0;        }    });pool.shutdown();</code></pre><p>线程之间通信</p><p>wait, notify、管道</p><p>Callable与Runnable区别</p><pre><code> FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() {                public Integer call() throws Exception {                    return 0;                }});new Thread(futureTask).start();futureTask.get();</code></pre><p>Callable 与 Runnable的区别就是，Callable可以获得一个返回值。通过Future#get方法来获取（此方法是一个阻塞方法）。</p><p>Synchronized与ReentrantLock区别</p><p><code>ReetrantLock</code> 显式锁，可以直接获取条件对象 lock.newConditon()。通过Condition的await()和signal()/signalAll()方法来使线程处于释放锁并处于等待状态， 解除等待状态。比 Synchronized 更多的用处。 </p><p><code>Synchronized</code> 每个对象都内置了一个隐式锁， 通过Object的wait()和notify()/notifiyAll() 来添加到条件的等待集， 解除等待状态。 更简单，    可直接放在方法上，避免出错。但相比显式锁更有局限性，不能中断一个正在试图获取锁的进程（阻塞状态），试图获取锁不能设定超时，每个锁只有一个条件，可能不够。</p><p>volatile有什么用</p><p>保证共享变量的可见性(立即刷新到主内存)，有序性(防止重排序)，但不能保证原子性。</p><p>同步器：信号量/倒计时门栓/栅栏/交换器/同步队列</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><pre><code>public class SThread {    public static void main(String[] args) {        ExecutorService service = Executors.newCachedThreadPool();        final Semaphore semp = new Semaphore(5);        for(int i = 0;i &lt; 20;i++){            final  int NO = i;            service.execute(new Runnable() {                @Override                public void run() {                    try {                        semp.acquire();                        System.out.println(&quot;access :&quot;  + NO);                        semp.release();                        System.out.println(&quot;--------&quot; + semp.availablePermits());                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            });        }        service.shutdown();    }}</code></pre><h4 id="倒计时门栓"><a href="#倒计时门栓" class="headerlink" title="倒计时门栓"></a>倒计时门栓</h4><pre><code>public class CThread {public static void main(String[] args) {    final CountDownLatch latch = new CountDownLatch(2);    new Thread(new Runnable() {        @Override        public void run() {            try {                System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;正在执行&quot;);                Thread.sleep(3000);                System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;);                latch.countDown();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }).start();    new Thread(new Runnable() {        @Override        public void run() {            try {                System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;正在执行122222222&quot;);                Thread.sleep(3000);                System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;);                latch.countDown();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }).start();    try {        System.out.println(&quot;等待2个子线程执行完毕...&quot;);        latch.await();        System.out.println(&quot;2个子线程已经执行完毕&quot;);        System.out.println(&quot;继续执行主线程&quot;);    } catch (InterruptedException e) {        e.printStackTrace();    }}}</code></pre><h4 id="循环栅栏-回环屏障"><a href="#循环栅栏-回环屏障" class="headerlink" title="循环栅栏(回环屏障)"></a>循环栅栏(回环屏障)</h4><pre><code>public class BThread {    public static void main(String[] args) {        int N = 4;        CyclicBarrier barrier  = new CyclicBarrier(N, new Runnable() {            @Override            public void run() {                System.out.println(&quot;do something&quot;);            }        });        for(int i=0;i&lt;N;i++)            new Writer(barrier).start();    }    static class Writer extends Thread{        private CyclicBarrier cyclicBarrier;        public Writer(CyclicBarrier cyclicBarrier) {            this.cyclicBarrier = cyclicBarrier;        }        @Override        public void run() {            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);            try {                Thread.sleep(5000);      //以睡眠来模拟写入数据操作                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);                cyclicBarrier.await();            } catch (InterruptedException e) {                e.printStackTrace();            }catch(BrokenBarrierException e){                e.printStackTrace();            }            System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);        }    }}</code></pre><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p><strong>BlockingQueue</strong> 是 java.util.concurrent 包中 放入和拿出形式的线程安全的队列。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">Throws Exception</th><th style="text-align:center">Special Value</th><th style="text-align:center">Blocks</th><th style="text-align:center">Times Out</th></tr></thead><tbody><tr><td style="text-align:left">Insert</td><td style="text-align:center">add(o)</td><td style="text-align:center">offer(o)</td><td style="text-align:center">put(o)</td><td style="text-align:center">offer(o, timeout, timeunit)</td></tr><tr><td style="text-align:left">Remove</td><td style="text-align:center">remove(o)</td><td style="text-align:center">poll()</td><td style="text-align:center">take()</td><td style="text-align:center">poll(timeout, timeunit)</td></tr><tr><td style="text-align:left">Examine</td><td style="text-align:center">element()</td><td style="text-align:center">peek()</td></tr></tbody></table><ol><li>Throws Exception:<br>If the attempted operation is not possible immediately, an exception is thrown.</li><li>Special Value:<br>If the attempted operation is not possible immediately, a special value is returned (often true / false).</li><li>Blocks:<br>If the attempted operation is not possible immedidately, the method call blocks until it is.</li><li>Times Out:<br>If the attempted operation is not possible immedidately, the method call blocks until it is, but waits no longer than the given timeout. Returns a special value telling whether the operation succeeded or not (typically true / false).</li></ol><p>阻塞队列的实现：</p><ul><li>ArrayBlockingQueue  固定容量的队列</li><li>DelayQueue 阻塞直到延迟过期</li><li>LinkedBlockingQueue 动态容量队列</li><li>PriorityBlockingQueue 优先级容量队列 - 元素需实现Comparable， 但不一定是按优先级排序的，但第一个一定是优先级最高的元素 </li><li>SynchronousQueue 同步队列， 没有容量（或者说只能存一个）， 只能拿一个和取一个</li></ul><p><img src="/images/blocking-queue.png" alt="blockingQueue"></p><pre><code>public class BlockingQueueExample {    public static void main(String[] args) throws Exception {        BlockingQueue queue = new ArrayBlockingQueue(1024);        Producer producer = new Producer(queue);        Consumer consumer = new Consumer(queue);        new Thread(producer).start();        new Thread(consumer).start();        Thread.sleep(4000);    }}public class Producer implements Runnable{    protected BlockingQueue queue = null;    public Producer(BlockingQueue queue) {        this.queue = queue;    }    public void run() {        try {            queue.put(&quot;1&quot;);            Thread.sleep(1000);            queue.put(&quot;2&quot;);            Thread.sleep(1000);            queue.put(&quot;3&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}public class Consumer implements Runnable{    protected BlockingQueue queue = null;    public Consumer(BlockingQueue queue) {        this.queue = queue;    }    public void run() {        try {            System.out.println(queue.take());            System.out.println(queue.take());            System.out.println(queue.take());        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h4 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h4><p><img src="/images/exchanger.png" alt="exchanger"></p><pre><code>Exchanger exchanger = new Exchanger();ExchangerRunnable exchangerRunnable1 =        new ExchangerRunnable(exchanger, &quot;A&quot;);ExchangerRunnable exchangerRunnable2 =        new ExchangerRunnable(exchanger, &quot;B&quot;);new Thread(exchangerRunnable1).start();new Thread(exchangerRunnable2).start();public class ExchangerRunnable implements Runnable{    Exchanger exchanger = null;    Object    object    = null;    public ExchangerRunnable(Exchanger exchanger, Object object) {        this.exchanger = exchanger;        this.object = object;    }    public void run() {        try {            Object previous = this.object;            this.object = this.exchanger.exchange(this.object);            System.out.println(                    Thread.currentThread().getName() +                    &quot; exchanged &quot; + previous + &quot; for &quot; + this.object            );        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h4 id="ConcurrentMap"><a href="#ConcurrentMap" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h4><p>The java.util.concurrent.ConcurrentMap interface represents a Map which is capable of handling concurrent access (puts and gets) to it.</p><p>The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.</p><p>使用 ConcurrentMap 效率更更高，而不是HashTable</p><pre><code>ConcurrentMap concurrentMap = new ConcurrentHashMap();concurrentMap.put(&quot;key&quot;, &quot;value&quot;);Object value = concurrentMap.get(&quot;key&quot;);</code></pre><p>java并发工具参考: <a href="http://tutorials.jenkov.com/java-util-concurrent/index.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-util-concurrent/index.html</a></p><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><p>SCM GIT </p><p>获取帮助 - git help <verb>、 git <verb> –help、 man git-<verb></verb></verb></verb></p><p>与SVN的不同 </p><ul><li>分布式版本控制软件, 每个人的电脑上都保存了一个项目的所有版本副本，而SVN一旦远程服务器出错，版本数据将会丢失。</li><li>SVN的版本控制使用的是保存每一个版本的差异，而Git使用的是保存快照，所以Git切换版本特别快，但是使用了更多的空间。</li><li>Git切换分支很快，因为仅仅新建了一个hashcode，将HEAD指向了这个hashcode。</li></ul><p>Hello World</p><pre><code>git initgit add .git commit -m &quot;first-commit&quot;git log</code></pre><p>git init </p><p>初始化项目 - 在当前目录会出现一个隐藏文件夹.git，所有git的资源都放在这个目录下。这个操作仅仅创建了一些元数据，还没有开始跟踪项目里的任何一个文件。</p><p>git status</p><p>查看git状态</p><p>git add </p><pre><code>git add .git add *.c</code></pre><p>跟踪文件 - 添加到暂存区(index)</p><p>git commit</p><pre><code>git commit git commit -m &quot;message&quot;</code></pre><p>提交到本地版本仓库</p><p>git log</p><p>查看日志</p><p>git push</p><pre><code>git push -u origin master</code></pre><p>git remote </p><pre><code>git remote add origin http://192.168.2.230/zyl/git-testgit remote -vgit remote set-url origin http://192.168.2.230/zyl/git-testgit remote remove origingit remote rename origin origin2</code></pre><p>git clone</p><pre><code>git clone http://192.168.2.230/zyl/git-test</code></pre><p>git fetch</p><p>拉取元数据，并不拉取数据。</p><p>git merge</p><pre><code>git merge origin master    </code></pre><ul><li>快进</li><li>自动合并</li><li>冲突 </li></ul><p>git rebase</p><p>衍合</p><pre><code>git rebase</code></pre><p><img src="/images/merge.jpg" alt=""></p><pre><code>git merge mywork origin</code></pre><p><img src="/images/rebase0.jpg" alt=""><br><img src="/images/rebase.jpg" alt=""></p><pre><code>git rebase mywork origin</code></pre><p>相当于git merge，但是要和git merge的区别就是git merge产生冲突时会新建一个分支但不会更改原来的分支,git rebase直接删掉自己的分支然后再新建一个分支,如果没有产生冲突和git merge一模一样。</p><p>git pull</p><p>git pull = git fetch + git merge。</p><pre><code>git pull origin mastergit pull (如果设置了upstream)</code></pre><p>git reset</p><pre><code>git reset HEADgit reset --soft HEADgit reset --hard HEAD</code></pre><p>git checkout</p><pre><code>git checkout new_branchgit checkout -b new_branchgit checkout -- .</code></pre><p>git reflog</p><p>注意 reflog 只保存在本地</p><pre><code>git refloggit reset --hard HEAD@{1}</code></pre><p>git diff</p><pre><code>git diffgit diff HEAD^ HEAD git diff ds21fashafg gdg1fshkgit difftool --tool-helpgit config --global diff.tool bc3git config --global difftool.bc3.path &quot;c:/program files/beyond compare 3/bcomp.exe&quot;git config --global merge.tool bc3git config --global mergetool.bc3.path &quot;c:/program files/beyond compare 3/bcomp.exe&quot;</code></pre><p>git config</p><pre><code>git config --listgit config user.email xxx@xxx.comgit config user.name xxxgit config credential.helper storegit config http.proxy http://127.0.0.1:8118git config auto.crlf truegit config core.editor gvimgit config alias.commit ci</code></pre><p>gitk </p><p>带界面的git</p><pre><code>gitk --all</code></pre><p>.gitignore</p><p>忽略文件，例子</p><pre><code>*.c 忽略所有.c文件!lib.c lib.c除外/TODO 忽略根目录下的TODO文件夹doc/ 忽略doc文件夹下所有文件doc/*.txt 忽略doc/abc.txt但不忽略doc/server/arch.txt</code></pre><p>git tag</p><pre><code>git tag v1.0git push origin v1.0</code></pre><p>git hook 的使用。。。</p><h2 id="Maven使用"><a href="#Maven使用" class="headerlink" title="Maven使用"></a>Maven使用</h2><p>为什么用maven</p><p>maven - 构建工具， 使项目的构建简单化，并且有一个统一的本地仓库。</p><p>项目结构（约定优于配置的原则）</p><pre><code>src    \_ src        \_ main            \_ java            \_ resource        \_ test            \_ java    \_ targetpom.xml</code></pre><p>pom文件介绍</p><p>每个项目根目录都有一个pom文件, 用于配置maven。</p><p>maven 的生命周期</p><ul><li>清理</li><li>初始化</li><li>编译</li><li>测试</li><li>打包</li><li>集成测试</li><li>验证</li><li>部署</li><li>站点生成</li></ul><h4 id="再分为三类"><a href="#再分为三类" class="headerlink" title="再分为三类"></a>再分为三类</h4><ul><li>clean 清理项目</li><li>default 真正构建的所有步骤  |  ref: <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="noopener">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a><ul><li>validate</li><li>intitalize</li><li>generate-sources</li><li>process-sources</li><li>generate-resources</li><li>process-resources</li><li>compile</li><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources</li><li>generate-test-resources</li><li>process-test-resources</li><li>test-compile</li><li>process-test-classes</li><li>test</li><li>prepare-package</li><li>package</li><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verify</li><li>install 安装到本地</li><li>deploy 将最终的包复制到远程仓库</li></ul></li><li>site 建立和发布项目站点，MAVEN能基于POM所包含的信息，自动生成一个友好的站点</li></ul><p>maven常用命令: package/compile/clean/test</p><p>maven的属性</p><ul><li>内置属性 ${basedir} 项目根目录（即包含pom.xml的目录),${version} 表示项目版本</li><li>POM属性 引用POM文件中对应元素的值<ul><li>${project.build.sourceDirectory} 项目源码路径,默认为src/main/java</li><li>${project.build.testSourceDirectory} 项目测试源码路径,默认为src/test/java/</li><li>${project.build.directory} 项目构建输出目录，默认为target/</li><li>${proect.outputDirectory} 项目主代码编译目录，默认为target/classes/</li><li>${project.testOutputDirector} 项目测试代码编译输出目录,默认为target/test-classes</li><li>${project.groupId} 项目的groupId</li><li>${project.artifactId} 项目的artifactId</li><li>${project.version} 与${version}等价</li><li>${project.build.finalName} 项目打包输出文件的名称，默认为${project.artifactId}-${project.version}</li></ul></li><li>自定义属性，用<code>&lt;properties&gt;</code>元素定义的属性</li><li>Settings属性，如${settings.localRepositroy}</li><li>Java属性，所有的Java系统属性都可以使用Maven属性引用，如${user.home},可以用mvn help:system查看所有Java属性</li><li>环境变量属性,如${env.JAVA_HOME}，可以用mvn help:system查看所有环境变量</li></ul><p><strong>依赖</strong></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;&lt;/groupId&gt;    &lt;artifactId&gt;&lt;/artifactId&gt;    &lt;version&gt;&lt;/version&gt;    &lt;type&gt;&lt;/type&gt;    &lt;optional&gt;&lt;/optional&gt;    &lt;scope&gt;&lt;/scope&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;        &lt;/exclusion&gt;         ...    &lt;/exclusions&gt;&lt;/dependency&gt;</code></pre><ul><li>groupId、artifactId、version 基本坐标</li><li>type 依赖类型，对应项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar</li><li>scope 依赖的范围</li><li>optional 标记依赖是否可选</li><li>exclusions 用来排除传递性依赖</li></ul><p>依赖范围</p><ul><li>compile 编译依赖范围。默认</li><li>test 测试依赖范围 junit</li><li>priovided 已提供依赖范围 tomcat</li><li>runtime 运行时依赖范围 jdbc-driver</li><li>system 系统依赖范围</li><li>import (Maven 2.0.9)导入依赖范围</li></ul><p>传递性依赖</p><p>传递性依赖和依赖范围</p><p>依赖调解</p><p>依赖调解第一原则 路径最优者优先</p><ol><li>A-&gt;B-&gt;C-&gt;X(1.0) </li><li>A-&gt;D-&gt;X(2.0)</li></ol><p><em>选择2</em></p><p>依赖调解第二原则 第一声明者优先(Maven 2.0.9)</p><ol><li>A-&gt;B-&gt;Y(1.0)</li><li>A-&gt;C-&gt;Y(2.0)</li></ol><p>如果B的依赖声明在C之前，<em>Y（1.0）就会被解析使用</em></p><p>可选依赖<br><strong>依赖将不会被传递</strong>，例如项目B有2个数据库驱动，设置这2个数据库驱动为可选，其他项目依赖项目B的时候就不会下载这2个数据库<br><code>&lt;option&gt;true&lt;/option&gt;</code></p><p>排除依赖<br>如果你想排除掉某个传递性依赖，用<code>&lt;exclusions&gt;</code>,只需要<code>&lt;groupId&gt;</code>和<code>&lt;artifactId&gt;</code></p><pre><code>&lt;dependencies&gt;&lt;/dependency&gt;    &lt;groupId&gt;&lt;/groupId&gt;    &lt;artifactId&gt;&lt;/artifactId&gt;    &lt;version&gt;&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;&lt;/groupId&gt;            &lt;artifactId&gt;&lt;/artifactId&gt;         &lt;/exclusion&gt;      &lt;exclusions&gt;&lt;/dependency&gt;&lt;dependencies&gt;</code></pre><p>归类依赖</p><pre><code>&lt;properties&gt;    &lt;springframework.verision&gt;2.5&lt;/springframework.version&gt;&lt;/properties&gt;&lt;dependecies&gt;    &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;${springframework.version}&lt;/version&gt;    &lt;dependency&gt;&lt;/dependencies&gt;</code></pre><p>优化依赖<br><code>mvn dependency:list</code><br><code>mvn dependency:tree</code></p><p>maven 插件</p><p>插件目标：</p><p>一个插件目标就是一个功能。<br>如<code>dependency:analyze</code>、<code>dependency:tree</code>和<code>dependency:list</code>。</p><p>插件绑定 &amp; 内置绑定</p><p>Maven的生命周期与插件相互绑定，用以完成实际的构建任务。<br>为了让用户几乎不用任何配置就能构建Maven项目，Maven的核心为一些主要的生命周期阶段绑定了很多插件的目标。  </p><p>自定义绑定</p><pre><code>&lt;build&gt;    &lt;plugins&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;        &lt;version&gt;2.1.1&lt;/version&gt;        &lt;executions&gt;            &lt;execution&gt;                &lt;id&gt;attach-sources omg it&apos;s just a name&lt;/id&gt;                &lt;phase&gt;verify&lt;/phase&gt;                &lt;goals&gt;                    &lt;goal&gt;jar-no-fork&lt;/goal&gt;                &lt;/goals&gt;            &lt;/execution&gt;        &lt;/executions&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>maven 聚合与继承</p><p>聚合</p><p>想要一次构建两个项目，而不是分别到模块的目录下执行mvn命令。Maven聚合（或者成为多模块）这一特性就是为该需求服务的。<br>aggregator:</p><pre><code>&lt;project    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;    xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.sunyuki.ec&lt;/groupId&gt;    &lt;artifactId&gt;sunyuki-erp-aggregator&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;sunyuki ec erp&lt;/name&gt;      &lt;modules&gt;        &lt;module&gt;../sunyuki-erp-base&lt;/module&gt;        &lt;module&gt;../sunyuki-erp-api&lt;/module&gt;        &lt;module&gt;../sunyuki-erp-external-api&lt;/module&gt;    &lt;/modules&gt;  &lt;/project&gt;</code></pre><p>请注意<code>packaging</code>为<code>POM</code></p><p>继承</p><p>两个POM有着许多相同的配置，例如有相同的groupId和version。在maven中，POM的继承这样的机制能让我们抽取出重复的配置。<br>parent:</p><pre><code>&lt;project    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;    xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.sunyuki.ec&lt;/groupId&gt;    &lt;artifactId&gt;sunyuki-erp-parent&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;sunyuki ec erp&lt;/name&gt;  &lt;/project&gt;</code></pre><p>请注意<code>packaging</code>为<code>POM</code><br>child:</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;sunyuki-erp-api&lt;/artifactId&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;parent&gt;        &lt;groupId&gt;com.sunyuki.ec&lt;/groupId&gt;        &lt;artifactId&gt;sunyuki-erp-parent&lt;/artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;relativePath&gt;../sunyuki-erp-parent/pom.xml&lt;/relativePath&gt;    &lt;/parent&gt;  &lt;/project&gt;</code></pre><h4 id="可继承的POM元素"><a href="#可继承的POM元素" class="headerlink" title="可继承的POM元素"></a>可继承的POM元素</h4><ul><li>groupId</li><li>version</li><li>desciption</li><li>organization</li><li>inceptionYear</li><li>url</li><li>developers</li><li>contributors</li><li>distributionManagement</li><li>issueManagement</li><li>ciManagement</li><li>scm 软件配置管理（版本控制系统）</li><li>mailingLists</li><li>properties</li><li>dependecies</li><li>denpendecyManagement</li><li>repositroies</li><li>build 包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等</li><li>reporting</li></ul><p>依赖管理</p><p>依赖可以继承，这时候容易想到在父类配置<code>&lt;repositroies&gt;</code>而子类不配置<code>&lt;repositroies&gt;</code>就可以继承，是可行的，但是存在问题，不需要对应库的子模块就一定要继承父类的<code>&lt;repositroies&gt;</code>吗?<br>maven提供的dependecyManagement元素能让子模块继承到父模块的依赖配置，又不会让子类引入实际的依赖。<br>父类：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;    xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.sunyuki.ec&lt;/groupId&gt;    &lt;artifactId&gt;sunyuki-erp-parent&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;sunyuki ec erp&lt;/name&gt;    &lt;dependencyManagement&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt; &lt;/project&gt;</code></pre><p>子类也会继承到依赖管理，子类在写依赖时，version和scope都省去了，方便于统一管理<br>子类：</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;sunyuki-erp-external-api&lt;/artifactId&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;parent&gt;        &lt;groupId&gt;com.sunyuki.ec&lt;/groupId&gt;        &lt;artifactId&gt;sunyuki-erp-parent&lt;/artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;relativePath&gt;../sunyuki-erp-parent/pom.xml&lt;/relativePath&gt;    &lt;/parent&gt;     &lt;dependencies&gt;          &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependecies&gt;&lt;/project&gt;</code></pre><p>引入repositroyManagement的方式：</p><ul><li>复制</li><li>继承</li><li><p>import - 引入<code>com.juvenxu.mvnbook.account.accout-parent</code>项目的<code>dependencyManagement</code>，<code>scope</code>为<code>import</code>,<code>type</code>为<code>pom</code></p>  <dependencymanagement><br>      <dependencies><br>          <dependency><br>              <groupid>com.juvenxu.mvnbook.account</groupid><br>              <artifactid>accout-parent</artifactid><br>              <scope>import</scope><br>              <version>1.0-SNAPSHOT</version><br>              <type>pom</type><br>          </dependency><br>      </dependencies><br>  </dependencymanagement></li></ul><h2 id="没有了"><a href="#没有了" class="headerlink" title="没有了"></a>没有了</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于 Selenium 的自动化测试（三）</title>
      <link href="/selenium-3/"/>
      <url>/selenium-3/</url>
      
        <content type="html"><![CDATA[<p>Selenium 进阶。</p><a id="more"></a><h1 id="Seleium-进阶"><a href="#Seleium-进阶" class="headerlink" title="Seleium 进阶"></a>Seleium 进阶</h1><h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><p>数据驱动应该是自动化的一个进步；从它的本意来讲，数据的改变（更新）驱动自动化的执行，从而引起测试结果的改变。这显然是一个非常高级的概念和想法。其实，我们可直白的理解成参数化，输入数据的不同从而引起输出结果的变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">values=[<span class="string">'selenium'</span>,<span class="string">'webdriver'</span>,<span class="string">u'测试'</span>]</span><br><span class="line"><span class="keyword">for</span> serch <span class="keyword">in</span> values:</span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">"http://www.xxxx.com"</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(serch)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>文件参数化 - 创建 data.txt 文件，向文件内写放三行数据</p><pre><code>aabbcc</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line">source = open(<span class="string">"D:\\abc\\data.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line">values = source.readlines()</span><br><span class="line">source.close()</span><br><span class="line"><span class="comment"># 执行循环</span></span><br><span class="line"><span class="keyword">for</span> serch <span class="keyword">in</span> values:</span><br><span class="line">    browser = webdriver.Firefox()</span><br><span class="line">    browser.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">    browser.find_element_by_id(<span class="string">"kw"</span>).send_keys(serch)</span><br><span class="line">    browser.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line">    browser.quit()</span><br></pre></td></tr></table></figure><p>字典参数化 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">words = &#123;<span class="string">'user1'</span>: <span class="string">'123'</span>, <span class="string">'user2'</span>: <span class="string">'456'</span>, <span class="string">'user3'</span>: <span class="string">'789'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Chrome驱动实例</span></span><br><span class="line">driver = webdriver.Chrome(<span class="string">"e:\\chromedriver\\chromedriver.exe"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u, p) <span class="keyword">in</span> words.items():</span><br><span class="line">    driver.get(<span class="string">"https://secure.sunyuki.com/login"</span>)</span><br><span class="line">    driver.find_element_by_id(<span class="string">"username"</span>).send_keys(u)</span><br><span class="line">    driver.find_element_by_id(<span class="string">"password"</span>).send_keys(p)</span><br><span class="line">    driver.find_element_by_id(<span class="string">"login"</span>).click()</span><br><span class="line">    <span class="comment"># WebDriverWait(driver, 10).until(expected_conditions.visibility_of(driver.find_element_by_class_name('ib-msg')))</span></span><br><span class="line"></span><br><span class="line">    driver.implicitly_wait(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">print</span> driver.find_element_by_class_name(<span class="string">'ib-msg'</span>).text</span><br></pre></td></tr></table></figure><p>表单参数化(csv)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> csv <span class="comment">#导入 csv 包</span></span><br><span class="line"><span class="comment">#读取本地 CSV 文件</span></span><br><span class="line">my_file=<span class="string">'D:\\selenium_python\\data\\userinfo.csv'</span></span><br><span class="line">data=csv.reader(file(my_file,<span class="string">'rb'</span>))</span><br><span class="line"><span class="comment">#循环输出每一行信息</span></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">print</span> user[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> user[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> user[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">print</span> user[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="自动化测试模型"><a href="#自动化测试模型" class="headerlink" title="自动化测试模型"></a>自动化测试模型</h2><h3 id="线性测试"><a href="#线性测试" class="headerlink" title="线性测试"></a>线性测试</h3><p>通过录制或编写脚本，一个脚本完成一个场景（一组完整功能操作），通过对脚本的回放来进行自动化测试。</p><p>通过上面的两个脚本，我们发现它优势就是每一个脚本都是独立的，任何一个脚本文件拿出来就能单独运行；当然，缺点也很明显，用例的开发与维护成本很高：<br>一个用例对应一个脚本，假如登陆发生变化，用户名的属性发生改变，不得不需要对每一个脚本进行修改，测试用例形成一种规模，我们可能将大量的工作用于脚本的维护，从而失去自动化的意义。<br>这种模式下<strong>数据和脚本是混在一起的</strong>，如果数据发生变也需要对脚本进行修改。这种模式下脚本的没有可重复使用的概念。</p><h2 id="模块化与类库"><a href="#模块化与类库" class="headerlink" title="模块化与类库"></a>模块化与类库</h2><p>我们会清晰的发现在上面的脚本中，其实有不少内容是重复的；于是我们就考虑能不能把重复的部分<br>写成一个公共的模块，需要的时候进行调用，这样就大大提高了我们编写脚本的效率。</p><p><strong>login.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#登录模块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"tbUserName"</span>).send_keys(<span class="string">"username"</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">"tbPassword"</span>).send_keys(<span class="string">"456123"</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">"btnLogin"</span>).click()</span><br></pre></td></tr></table></figure><p><strong>qiut.py</strong>    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#退出模块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quit_</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>test1.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> login,quit_ <span class="comment">#调用登录、退出模块</span></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">"http://wwww.xxx.com"</span>)</span><br><span class="line"><span class="comment">#调用登录模块</span></span><br><span class="line">login.login()</span><br><span class="line"><span class="comment">#其它个性化操作</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">#调用退出模块</span></span><br><span class="line">quit.quit_()</span><br></pre></td></tr></table></figure><p>注意，上面用例非完整代码。<br>通过阅读上面的代码发现，我们可以把脚本中相同的部分代码独立出来，形成模块或库；这样做有两方面的优点：<br>一方面提高了开发效率，不用重复的编写相同的脚本；假如，我已经写好一个登录模块，我后续需要做的就是在需要的地方调用，不同重复造轮子。<br>另一方面方便了代码的维护，假如登录模块发生了变化，我只用修改 login.py 文件中登录模块的代码即可，那么所有调用登录模块的脚本不用做任何修改。</p><h2 id="项目结构的改进"><a href="#项目结构的改进" class="headerlink" title="项目结构的改进"></a>项目结构的改进</h2><h2 id="引入unittest-单元测试框架"><a href="#引入unittest-单元测试框架" class="headerlink" title="引入unittest 单元测试框架"></a>引入unittest 单元测试框架</h2><p>在一个.py 文件里编写多个测试用例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line">from selenium.webdriver.support.ui import Select</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">from selenium.common.exceptions import NoAlertPresentException</span><br><span class="line">import unittest, time, re</span><br><span class="line">from selenium.webdriver.support import expected_conditions</span><br><span class="line"></span><br><span class="line">from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Test(unittest.TestCase):</span><br><span class="line">    def setUp(self):</span><br><span class="line">        self.driver = webdriver.Chrome(&quot;e:\\chromedriver\\chromedriver.exe&quot;)</span><br><span class="line">        self.driver.implicitly_wait(30)</span><br><span class="line">        self.base_url = &quot;https://www.baidu.com&quot;</span><br><span class="line">        #self.verificationErrors = []</span><br><span class="line">        #self.accept_next_alert = True</span><br><span class="line"></span><br><span class="line">    def testBaidu(self):</span><br><span class="line">        driver = self.driver</span><br><span class="line">        driver.get(self.base_url + &quot;/&quot;)</span><br><span class="line">        driver.find_element_by_id(&quot;kw&quot;).click()</span><br><span class="line">        driver.find_element_by_id(&quot;kw&quot;).clear()</span><br><span class="line">        driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test&quot;)</span><br><span class="line">        driver.find_element_by_id(&quot;su&quot;).click()</span><br><span class="line">        WebDriverWait(driver, 10).until(expected_conditions.title_contains(&quot;test&quot;))</span><br><span class="line">        print driver.title</span><br><span class="line">        self.assertEqual(&quot;test_百度知道&quot;, driver.title)</span><br><span class="line"></span><br><span class="line">    def testSunyuki(self):</span><br><span class="line">        driver = self.driver</span><br><span class="line">        driver.get(&quot;https://secure.sunyuki.com/login&quot;)</span><br><span class="line">        driver.find_element_by_id(&quot;username&quot;).send_keys(&quot;test&quot;)</span><br><span class="line">        driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;test&quot;)</span><br><span class="line">        driver.find_element_by_id(&quot;login&quot;).click()</span><br><span class="line">        WebDriverWait(driver, 10).until(expected_conditions.visibility_of(driver.find_element_by_class_name(&apos;ib-msg&apos;)))</span><br><span class="line">        print driver.find_element_by_class_name(&apos;ib-msg&apos;)</span><br><span class="line">        self.assertEqual(&quot;登录账号或者密码错误。&quot;, driver.find_element_by_class_name(&apos;ib-msg&apos;).text)</span><br><span class="line"></span><br><span class="line">    def tearDown(self):</span><br><span class="line">        self.driver.quit()</span><br><span class="line">        ##self.assertEqual([], self.verificationErrors)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><h2 id="生成测试报告"><a href="#生成测试报告" class="headerlink" title="生成测试报告"></a>生成测试报告</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoAlertPresentException</span><br><span class="line"><span class="keyword">import</span> unittest, time, re</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HTMLTestRunner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.driver = webdriver.Chrome(<span class="string">"e:\\chromedriver\\chromedriver.exe"</span>)</span><br><span class="line">        self.driver.implicitly_wait(<span class="number">30</span>)</span><br><span class="line">        self.base_url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testBaidu</span><span class="params">(self)</span>:</span></span><br><span class="line">        driver = self.driver</span><br><span class="line">        driver.get(self.base_url + <span class="string">"/"</span>)</span><br><span class="line">        driver.find_element_by_id(<span class="string">"kw"</span>).click()</span><br><span class="line">        driver.find_element_by_id(<span class="string">"kw"</span>).clear()</span><br><span class="line">        driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"test"</span>)</span><br><span class="line">        driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line">        WebDriverWait(driver, <span class="number">10</span>).until(expected_conditions.title_contains(<span class="string">"test"</span>))</span><br><span class="line">        <span class="keyword">print</span> driver.title.encode(<span class="string">"utf-8"</span>)</span><br><span class="line">        self.assertEqual(<span class="string">"test_百度搜索"</span>, driver.title.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># self.driver.quit()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    testunit = unittest.TestSuite()</span><br><span class="line">    testunit.addTest(Test(<span class="string">"testBaidu"</span>))</span><br><span class="line"></span><br><span class="line">    filename = <span class="string">'E:\\test\\report.html'</span></span><br><span class="line">    fp = file(filename, <span class="string">'wb'</span>)</span><br><span class="line">    runner = HTMLTestRunner.HTMLTestRunner(</span><br><span class="line">        stream=fp,</span><br><span class="line">        title=<span class="string">'百度搜索测试报告'</span>,</span><br><span class="line">        description=<span class="string">'用例执行情况：'</span>)</span><br><span class="line">    runner.run(testunit)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于 Selenium 的自动化测试（二）</title>
      <link href="/selenium-2/"/>
      <url>/selenium-2/</url>
      
        <content type="html"><![CDATA[<p>使用 selenium 网页自动化。</p><a id="more"></a><h1 id="前端技术介绍"><a href="#前端技术介绍" class="headerlink" title="前端技术介绍"></a>前端技术介绍</h1><h4 id="HTML-简介"><a href="#HTML-简介" class="headerlink" title="HTML 简介"></a>HTML 简介</h4><p>HTML（Hyper Text Markup Language）中文为超文本标记语言，HTML 是网页的基础，它并不是一种<br>编程语言，而是一种标记语言（一套标记标签），但我们可以在 HTML 标签中嵌入各种前端脚本语言，如<br>VBScript、JavaScript 等。下面是一个简单的 HTML 页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">h1</span>&gt;</span>正文<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>&lt;html&gt; 与 &lt;/html&gt; 之间的文本描述网页  &lt;title&gt; 与 &lt;/title&gt; 之间的内容显示在浏览器的标题栏  &lt;body&gt; 与 &lt;/body&gt; 之间的文本是可见的页面内容  &lt;h1&gt; 与 &lt;/h1&gt; 之间的文本被显示为正文，h1 为页面中的一号字体  </code></pre><p>现在我们通过浏览器打开任意一个页面，在页面上右键菜单选择“查看网页源代码”，在复杂的前端代码中你依然可以找到 HTML 的身影。</p><h4 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h4><p>JavaScript 是一种由 Netscape 公司的 LiveScript 发展而来的前端脚本语言（脚本语言是一个种轻量级的语言），是一种解释性语言（代码执行不需要预编译）；被设计用来向 HTML 页面添加交互行为，通常被直接嵌入到 HTML 页面。<br>如果要在 HTML 页面中使用 JavaScript ，我们需要使用<code>&lt;script&gt;</code>标签，同时使用 type 属性来定义脚本语言：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"Hello World!"</span>);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="简单对象定位"><a href="#简单对象定位" class="headerlink" title="简单对象定位"></a>简单对象定位</h4><pre><code>find_element_by_id()find_element_by_name()find_element_by_class_name()find_element_by_tag_name()find_element_by_link_text()find_element_by_partial_link_text()find_element_by_xpath()find_element_by_css_selector()</code></pre><ul><li><p>id 和 name</p><p>  id 和 name 是我们最常用的定位方式，因为大多数元素都有这两个属性，而且在对控件的 id 和 name命名时一般使其有意义也会取不同的名字。通过这两个属性使我们找一个页面上的属性变得相当容易。</p><pre><code>&lt;input id=&quot;gs_htif0&quot; class=&quot;gsfi&quot; aria-hidden=&quot;true&quot; dir=&quot;ltr&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;btnK&quot; jsaction=&quot;sf.chk&quot; value=&quot;Google 搜索&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;btnI&quot; jsaction=&quot;sf.lck&quot; value=&quot; 手气不错 &quot;&gt;id=”gs_htif0”find_element_by_id(&quot;gs_htif0&quot;)name=”btnK”find_element_by_name(&quot;btnK&quot;)</code></pre></li><li><p>tag name 和 class name</p><p>不是所有的前端开发人员都喜欢为每一个元素添加 id 和 name 两个属性，但除此之外你一定发现了一个元素不单单只有 id 和 name，它还有 class 属性；而且每个元素都会有标签。    </p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"searchform"</span> <span class="attr">class</span>=<span class="string">"jhp_big"</span> <span class="attr">style</span>=<span class="string">"margin-top:-2px"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"tsf"</span> <span class="attr">onsubmit</span>=<span class="string">"return name="</span><span class="attr">f</span>" <span class="attr">method</span>=<span class="string">"GET"</span> <span class="attr">action</span>=<span class="string">"/search"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"kw"</span> <span class="attr">class</span>=<span class="string">"s_ipt"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"wd"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class=”jhp_big”</span><br><span class="line">find_element_by_class_name("jhp_big")</span><br><span class="line">class=”s_ipt”</span><br><span class="line">find_element_by_class_name("s_ipt")</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">find_element_by_tag_name("div")</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">find_element_by_tag_name("form")</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">find_element_by_tag_name("input")</span><br></pre></td></tr></table></figure><p>tag name 定位应该是所有定位方式中最不靠谱的一种了，因为在一个页面中具有相同 tag name 的元素极其容易出现。</p><ul><li><p>link text 与 partial link text 定位</p><p>  有时候需要操作的元素是一个文字链接，那么我们可以通过 link text 或 partial link text 进行元素定位。</p></li></ul><pre><code>&lt;a href=&quot;http://news.baidu.com&quot; name=&quot;tj_news&quot;&gt;新 闻&lt;/a&gt;&lt;a href=&quot;http://tieba.baidu.com&quot; name=&quot;tj_tieba&quot;&gt;贴 吧&lt;/a&gt;&lt;a href=&quot;http://zhidao.baidu.com&quot; name=&quot;tj_zhidao&quot;&gt;一个很长的文字连接&lt;/a&gt;通过 link text 定位元素：find_element_by_link_text(&quot;新 闻&quot;)find_element_by_link_text(&quot;贴 吧&quot;)find_element_by_link_text(&quot;一个很长的文字连接&quot;)通 partial link text 也可以定位到上面几个元素：find_element_by_partial_link_text(&quot;新&quot;)find_element_by_partial_link_text(&quot;吧&quot;)find_element_by_partial_link_text(&quot;一个很长的&quot;)</code></pre><ul><li><p>CSS 定位</p><p>  CSS(Cascading Style Sheets)是一种语言，它被用来描述 HTML 和 XML 文档的表现。CSS 使用选择器来为页面元素绑定属性。这些选择器可以被 selenium 用作另外的定位策略。<br>  CSS 可以比较灵活选择控件的任意属性，一般情况下定位速度要比 XPath 快，但对于初学者来说比较<br>  难以学习使用，下面我们就详细的介绍 CSS 的语法与使用。<br>  CSS 选择器的常见语法：</p><p>  <a href="http://me10zyl.github.io/demos/html5demos/4/jqueryselectors/index.html" target="_blank" rel="noopener">http://me10zyl.top/demos/html5demos/4/jqueryselectors/index.html</a></p><p>  w3c标准： <a href="https://www.w3.org/TR/CSS/#selectors" target="_blank" rel="noopener">https://www.w3.org/TR/CSS/#selectors</a></p></li><li><p>XPath 定位</p><p>  XPath 是一种在 XML 文档中定位元素的语言。因为 HTML 可以看做 XML 的一种实现，所以 selenium 用户可是使用这种强大语言在 web应用中定位元素。<br>  XPath 扩展了上面 id 和 name 定位方式，提供了很多种可能性，比如定位页面上的第三个多选框</p></li></ul><pre><code>&lt;html class=&quot;w3c&quot;&gt;&lt;body&gt;&lt;div class=&quot;page-wrap&quot;&gt;&lt;div id=&quot;hd&quot; name=&quot;q&quot;&gt;&lt;form target=&quot;_self&quot; action=&quot;http://www.so.com/s&quot;&gt;&lt;span id=&quot;input-container&quot;&gt;&lt;input id=&quot;input&quot; type=&quot;text&quot; x-webkit-speech=&quot;&quot; autocomplete=&quot;off&quot;suggestwidth=&quot;501px&quot; &gt;我们看到的是一个有层级关系页面，下面我看看如果用 xpath 来定位最后一个元素。用绝对路径定位:find_element_by_xpath(&quot;/html/body/div[2]/form/span/input&quot;)当我们所要定位的元素很难找到合适的方式时，都可以通这种绝对路径的方式位，缺点是当元素在很多级目录下时，我们不得不要写很长的路径，而且这种方式难以阅读和维护。相对路径定位:find_element_by_xpath(&quot;//input[@id=’input’]&quot;) #通过自身的 id 属性定位find_element_by_xpath(&quot;//span[@id=’input-container’]/input&quot;) #通过上一级目录的id属性定位find_element_by_xpath(&quot;//div[@id=’hd’]/form/span/input&quot;) #通过上三级目录的 id 属性定位find_element_by_xpath(&quot;//div[@name=’q’]/form/span/input&quot;)#通过上三级目录的 name 属性定位通过上面的例子，我们可以看到 XPath 的定位方式非常灵活和强大的，而且 XPath 可以做布尔逻辑运算，例如：//div[@id=’hd’ or @name=’q’]当然，它的缺陷也非常明显：1、性能差，定位元素的性能要比其它大多数方式差；2、不够健壮，XPath会随着页面元素布局的改变而改变；3. 兼容性不好，在不同的浏览器下对 XPath 的实现是不一样的。</code></pre><h3 id="操作测试对象"><a href="#操作测试对象" class="headerlink" title="操作测试对象"></a>操作测试对象</h3><p>webdriver 中比较常用的操作元素的方法有下面几个：</p><ul><li>clear 清除元素的内容，如果可以的话</li><li>send_keys 在元素上模拟按键输入</li><li>click 单击元素</li><li>submit 提交表单</li></ul><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><pre><code>size=driver.find_element_by_id(&quot;kw&quot;).sizetext=driver.find_element_by_id(&quot;cp&quot;).textattribute=driver.find_element_by_id(&quot;kw&quot;).get_attribute(&apos;type&apos;)</code></pre><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>ActionChains 类鼠标操作的常用方法：</p><ul><li>context_click() 右击</li><li>double_click() 双击</li><li>drag_and_drop() 拖动</li><li>move_to_element() 鼠标悬停在一个元素上</li><li>click_and_hold() 按下鼠标左键在一个元素上</li><li>context_click() 右键点击一个元素</li></ul><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>下面经常使用到的键盘操作：</p><ul><li>send_keys(Keys.BACK_SPACE) 删除键（BackSpace）</li><li>send_keys(Keys.SPACE) 空格键(Space)</li><li>send_keys(Keys.TAB) 制表键(Tab)</li><li>send_keys(Keys.ESCAPE) 回退键（Esc）</li><li>send_keys(Keys.ENTER) 回车键（Enter）</li><li>send_keys(Keys.CONTROL,’a’) 全选（Ctrl+A）</li><li>send_keys(Keys.CONTROL,’c’) 复制（Ctrl+C）</li><li>send_keys(Keys.CONTROL,’x’) 剪切（Ctrl+X）</li><li>send_keys(Keys.CONTROL,’v’) 粘贴（Ctrl+V）</li></ul><h3 id="设置等待时间"><a href="#设置等待时间" class="headerlink" title="设置等待时间"></a>设置等待时间</h3><ul><li>implicitly_wait() 隐式等待</li><li>WebDriverWait() 显式等待(智能)</li><li>sleep() 显式等待</li></ul><pre><code>#coding=utf-8from selenium import webdriver#导入 WebDriverWait 包from selenium.webdriver.support.ui import WebDriverWait#导入 time 包import timedriver = webdriver.Firefox()driver.get(&quot;http://www.baidu.com&quot;)#WebDriverWait()方法使用element=WebDriverWait(driver, 10).until(lambda driver :driver.find_element_by_id(&quot;kw&quot;))element.send_keys(&quot;selenium&quot;)#添加智能等待driver.implicitly_wait(30)driver.find_element_by_id(&quot;su&quot;).click()#添加固定休眠时间time.sleep(5)driver.quit()</code></pre><h3 id="Python-Ttutorial"><a href="#Python-Ttutorial" class="headerlink" title="Python Ttutorial"></a>Python Ttutorial</h3><p><a href="https://www.stavros.io/tutorials/python/" target="_blank" rel="noopener">python in ten minutes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于 Selenium 的自动化测试（一）</title>
      <link href="/selenium-1/"/>
      <url>/selenium-1/</url>
      
        <content type="html"><![CDATA[<p>selenium 基础。</p><a id="more"></a><h1 id="Seleium-基础"><a href="#Seleium-基础" class="headerlink" title="Seleium 基础"></a>Seleium 基础</h1><h2 id="发音"><a href="#发音" class="headerlink" title="发音"></a>发音</h2><p>  <code>Seleium 英 [s?&#39;li?n??m] 美 [s?&#39;lin??m]</code></p><h2 id="什么是-Selenium"><a href="#什么是-Selenium" class="headerlink" title="什么是 Selenium"></a>什么是 Selenium</h2><p><code>Selenium</code> 是一款浏览器自动化工具，主要是<strong>以测试网页应用为目的</strong>，但是不只限于这个用途，比如枯燥的后台管理任务也可以自动化（基于网页）。</p><p>一些主流浏览器已经内部支持或者正在准备支持<code>Selenium</code> 作为浏览器的一部分，<code>Selenium</code> 也是数不清的自动化工具、API和框架的核心技术。</p><p>官方网站:<a href="http://www.seleniumhq.org/" target="_blank" rel="noopener">http://www.seleniumhq.org/</a>（HQ是headquater的简称 - 总部)</p><p>selenium 的特点：</p><ul><li>开源，免费</li><li>多浏览器支持：FireFox、Chrome、IE、Opera</li><li>多平台支持：linux 、windows、MAC</li><li>多语言支持：java、python、ruby、php、C#、JavaScript</li><li>对 web 页面有良好的支持</li><li>简单（API 简单）、灵活（用开发语言驱动）</li><li>支持分布式测试用例执行</li></ul><hr><ul><li><p><strong>Selenium 1.0</strong><br><img src="http://note.youdao.com/yws/api/personal/file/182FB56BDCEC42689BAD333B9E5E8A8F?method=download&amp;shareKey=505e7160f840d4cf5d841fc1285bd79f" alt="alt"></p></li><li><p><strong>Selenium 2.0</strong>  </p></li></ul><p>搞清了 selenium 1.0 的家族关系，selenium 2.0 是把 WebDriver 加入到了这个家族中；简单用公式表示为：</p><pre><code>selenium 2.0 = selenium 1.0 + WebDriver</code></pre><p>在 selenium 2.0 中主推的是 WebDriver ，WebDriver 是 selenium RC 的替代品，因为 selenium 为了向下兼容性，所以 selenium RC 并没有彻底抛弃，如果你使用 selenium 开发一个新自动化测试项目，强列推荐使用 WebDriver 。那么 selenium RC 与 webdriver 主要有什么区别呢？<br>selenium RC 在浏览器中<strong>运行 JavaScript 应用</strong>，使用浏览器内置的 JavaScript 翻译器来翻译和执行selenese 命令（selenese 是 selenium 命令集合）。<br>WebDriver 通过原生浏览器支持或者浏览器扩展直接控制浏览器。WebDriver 针对各个浏览器而开发，取代了嵌入到被测 Web 应用中的 JavaScript。与浏览器的紧密集成支持创建更高级的测试，避免了<br>JavaScript 安全模型导致的限制。除了来自<strong>浏览器厂商的支持</strong>(wire协议)，WebDriver还利用操作系统级的调用模拟用户输入。</p><h2 id="哪部分-Selenium-适合我？"><a href="#哪部分-Selenium-适合我？" class="headerlink" title="哪部分 Selenium 适合我？"></a>哪部分 Selenium 适合我？</h2><p><img src="http://www.seleniumhq.org/images/selenium-logo.png" alt="se-webdriver"><br><img src="http://www.seleniumhq.org/images/selenium-grid-logo.png" alt="se-gird"><br>Selenium WebDriver  </p><ul><li>创建基于浏览器的回归自动化测试套件</li><li>基于脚本的多环境测试</li></ul><p><code>Selenium WebDriver</code>，可以使用一组特定语言来驱动浏览器。<br><code>Selenium WebDriver</code> 是 <code>Selenium Remote Control</code>的继承者，而<code>Selenium Remote Control</code>就是第一代<code>Selenium</code>。</p><p><img src="http://www.seleniumhq.org/images/selenium-ide-logo.png" alt="se-ide"><br>Selenium IDE</p><ul><li>录入和回放，并且可以生成脚本</li><li>帮助创建探索性的脚本</li></ul><p><code>Selenium IDE</code>是一个Firefox（火狐）浏览器的插件，可以快速的录入和回放网页操作，并且可以生成脚本。</p><h2 id="Selienium-IDE"><a href="#Selienium-IDE" class="headerlink" title="Selienium IDE"></a>Selienium IDE</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在线安装： <a href="https://addons.mozilla.org/zh-CN/firefox/addon/selenium-ide/" target="_blank" rel="noopener">https://addons.mozilla.org/zh-CN/firefox/addon/selenium-ide/</a></p><p><img src="http://note.youdao.com/yws/api/personal/file/69FDBAE160D045619190D3865D0C2318?method=download&amp;shareKey=6c008d99689b6cf6f4ca8c6916a8fa8d" alt="seide"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>录制回放功能</li><li>使用 ID names XPath 来定位元素</li><li>自动补全 Selenium 命令</li><li>运行测试用例</li><li>调试和设置断点</li><li>导出测试（可导出 html python ruby 脚本等格式）</li><li>可断言每个页面的标题</li><li>支持 Selenium user-extensions.js 文件</li><li>可通过插件定制</li></ul><h2 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h2><p><code>selenium webdriver</code> 可以使用<code>java、csharp、python、ruby、php、perl、javascript</code>作为脚本语言。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ol><li>安装 <code>python</code> (<a href="https://www.python.org/ftp/python/2.7.13/python-2.7.13.msi" target="_blank" rel="noopener">https://www.python.org/ftp/python/2.7.13/python-2.7.13.msi</a></li><li><p><code>Win + R -&gt; cmd</code></p><pre><code>pip install seleium</code></pre></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait <span class="comment"># available since 2.4.0</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC <span class="comment"># available since 2.26.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Chrome驱动实例</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问百度主页</span></span><br><span class="line">driver.get(<span class="string">"http://www.baidu.com/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印网页标题</span></span><br><span class="line"><span class="keyword">print</span> driver.title</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到name为wd的文本框(百度搜索框)</span></span><br><span class="line">inputElement = driver.find_element_by_name(<span class="string">"wd"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文本框中输入值</span></span><br><span class="line">inputElement.send_keys(<span class="string">"cheese!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交表单</span></span><br><span class="line">inputElement.submit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 等待页面刷新 直到网页标题包含cheese! 或者 超过10秒</span></span><br><span class="line">    WebDriverWait(driver, <span class="number">10</span>).until(EC.title_contains(<span class="string">"cheese!"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再打印下标题 现在应该是cheese!_百度搜索</span></span><br><span class="line">    <span class="keyword">print</span> driver.title</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 驱动退出</span></span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h3 id="驱动下载"><a href="#驱动下载" class="headerlink" title="驱动下载"></a>驱动下载</h3><ul><li><a href="https://chromedriver.storage.googleapis.com/2.28/chromedriver_win32.zip" target="_blank" rel="noopener">Chrome</a></li><li><a href="https://github.com/mozilla/geckodriver/releases/download/v0.15.0/geckodriver-v0.15.0-win64.zip" target="_blank" rel="noopener">Firefox</a></li></ul><h2 id="PhantomJS"><a href="#PhantomJS" class="headerlink" title="PhantomJS"></a>PhantomJS</h2><h3 id="PhantomJS-简介"><a href="#PhantomJS-简介" class="headerlink" title="PhantomJS 简介"></a>PhantomJS 简介</h3><blockquote><p>PhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG.</p></blockquote><p>简单理解：<code>PhantomJS</code>是一个无界面浏览器。<a href="http://phantomjs.org/" target="_blank" rel="noopener">http://phantomjs.org/</a></p><p>phantomJS 特点：</p><ul><li>无界面网页测试</li><li>网页截图</li><li>页面自动化</li><li>网络监视</li></ul><h3 id="Selenium-PhantomJS"><a href="#Selenium-PhantomJS" class="headerlink" title="Selenium + PhantomJS"></a>Selenium + PhantomJS</h3><p>在selenium中使用phantomjs的好处就是：速度快。使用PhantomJS，只需将驱动换成phantomJS即可。</p><pre><code>webdriver.PhantomJS()</code></pre><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h4 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h4><ul><li><a href="https://addons.mozilla.org/zh-CN/firefox/addon/selenium-ide/" target="_blank" rel="noopener">Selenium IDE 下载</a></li><li><a href="https://www.python.org/ftp/python/2.7.13/python-2.7.13.msi" target="_blank" rel="noopener">Python 下载</a></li><li><a href="https://chromedriver.storage.googleapis.com/2.28/chromedriver_win32.zip" target="_blank" rel="noopener">Chrome 驱动下载</a></li><li><a href="https://github.com/mozilla/geckodriver/releases/download/v0.15.0/geckodriver-v0.15.0-win64.zip" target="_blank" rel="noopener">Firefox 驱动下载</a></li><li><a href="https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-windows.zip" target="_blank" rel="noopener">PhantomJS 下载</a></li><li><a href="https://www.jetbrains.com/pycharm/download" target="_blank" rel="noopener">Pycharm 下载</a></li></ul><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><ul><li><a href="http://www.seleniumhq.org" target="_blank" rel="noopener">Selenium 官方网站</a></li><li><a href="http://phantomjs.org/" target="_blank" rel="noopener">PhantomJS 官方网站</a></li><li><a href="https://www.python.org/" target="_blank" rel="noopener">Python 官方网站</a></li><li><a href="http://www.seleniumhq.org/docs/03_webdriver.jsp" target="_blank" rel="noopener">Selenium Webdriver 文档</a></li><li><a href="http://seleniumhq.github.io/selenium/docs/api/py/index.html" target="_blank" rel="noopener">Selenium Python API 文档</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件测试概念</title>
      <link href="/selenium-0/"/>
      <url>/selenium-0/</url>
      
        <content type="html"><![CDATA[<p>软件测试的概念。</p><a id="more"></a><h1 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h1><p>根据<em>项目流程</em>阶段划分软件测试</p><ul><li><p><strong>单元测试</strong>：单元测试（或模块测试）是对程序中的单个子程序或具有独立功能的代码段进行测试的过程。</p></li><li><p><strong>集成测试</strong>：集成测试是单元测试的基础上，将通过单元模块组装成系统或子系统，再进行测试，重点是检查模块之间的接口是否正确。</p></li><li><p><strong>系统测试</strong>：系统测试是针对整个产品系统进行的测试，验证系统是否满足了需求规格的定义，以及软件系统的正确性和性能等是否满足其规约所指定的要求。</p></li><li><p><strong>验收测试</strong>：验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，向软件购买都展示该软件系统满足其用户的需求。</p></li></ul><p>对软件代码的<em>可见程度</em>进行的划分：</p><ul><li><p><strong>黑盒测试</strong>：<br>黑盒测试，指的是把被测的软件看作是一个黑盒子，我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。<br>它只检查程序呈现给用户的功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p></li><li><p><strong>白盒测试</strong>：<br>白盒测试，指的是把盒子打开，去研究里面的源代码和程序执行结果。<br>它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正<br>常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p></li><li><p><strong>灰盒测试</strong>：<br>灰盒测试介于黑盒测试与白盒测试之间。<br>可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那<br>样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，<br>但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取<br>这样的一种灰盒测试的方法。</p></li></ul><p>从对软件的不同<em>测试点</em>可以划分：</p><ul><li><strong>功能测试</strong><br>功能测试检查实际的功能是否符合用户的需求。测试的大部分工作也是围绕软件的功能进行，设计软<br>件的目的也就是满足客户对其功能的需求。如果偏离的这个目的任何测试工作都是没有意义的。<br>功能测试又可以细分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等。</li><li><strong>性能测试</strong><br>性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进<br>行测试。<br>软件的性能包括很多方面，主要有时间性能和空间性能两种。</li><li><strong>时间性能</strong>：主要是指软件的一个具体的响应时间。比如一个登录所需要的时间，一个交易所需要的时<br>间等。当然，抛开具体的测试环境，来分析一次事务的响应时间是没有任何意义的。需要搭建一个具体且<br>独立的测试环境。</li><li><strong>空间性能</strong>：主要指软件运行时所消耗的系统资源，比如硬件资源，CPU、内存，网络带宽消耗等。</li></ul><p>从对软件测试工作的<em>自动化程度</em>划分：</p><ul><li><p><strong>手工测试</strong>：<br>手工测试就是由人去一个一个的去执行测试用例，通过键盘鼠标等输入一些参数，查看返回结果是否<br>符合预期结果。<br>手工测试并不非专业术语，手工测试通常是指我们在系统测试阶段所进行的功能测试，为了更明显的<br>与自动化测试进行区分，所以这里使用了手工测试。</p></li><li><p><strong>自动化测试</strong><br>自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。通常，在设计了测试用例并通过<br>评审之后，由测试人员根据测试用例中描述的规程一步步执行测试，得到实际结果与期望结果的比较。在<br>此过程中，为了节省人力、时间或硬件资源，提高测试效率，便引入了自动化测试的概念。</p></li></ul><p>自动化测试又可分为：<strong>功能自动化测试</strong>与<strong>性能自动化测试</strong>。</p><p>我们一般所说的自动化测试就是指功能自动化测试，通过相关的测试技术，通过编码的方式用一段程序来测试一个软件的功能，这样就可以重复执行程序来进行重复的测试。如果一个软件一小部分发生改变，我们只要修改一部分自动化测试代码，就可以重复的对整个软件进行功能测试；从而大大的提高了测试效率。<br>性能自动化测试，当然，除了早期阶段，现在的性能测试工作都是通过性能测试工具辅助完成的。通过工具可以模拟成千上万的用户向系统发送请求，用来验证系统的处理能力。</p><p><strong>冒烟测试</strong>、<strong>回归测试</strong>、<strong>随机测试</strong></p><p>这三种测试出现在软件功能测试周期中，既不算具体明确的测试阶段也不是具体的测试方法。</p><ul><li><p><strong>冒烟测试</strong>：<br>是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。<br>引入到软件测试中，就是指测试小组在正规测试一个新版本之前，先投入较少的人力和时间验证一个软件的主要功能，如果主要功能都没有实现，则打回开发组重新开发。这样做的好处是可以节省大量的<br>时间成本和人力成本。</p></li><li><p><strong>回归测试</strong>：<br>回归测试是指修改了旧代码后，重新进行测试以确认修改后没有引入新的错误或导致其他代码产生错<br>误。<br>回归测试一般是在进行软件的第二轮测试开始的，验证第一轮中发现的问题是否得到修复。当然，回<br>归也是一个循环的过程，如果回归的问题通不过，则需要开发人员修改后再次进行回归，直到通过为止。</p></li><li><p><strong>随机测试</strong>：<br>是指测试中的所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错<br>误。<br>随机测试可以发现一些隐蔽的错误，但是也有很多缺点，比如测试不系统，无法统计代码覆盖率和需<br>求覆盖率，发现的问题难以重现。一般是放在测试的最后执行。其实随机测试更专业的升级版叫 探索性<br>测试</p></li><li><p><strong>探索性测试</strong>：<br>探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试<br>用例设计过程，强调在碰到问题时及时改变测试策略。</p></li><li><p><strong>安全测试</strong>：<br>安全测试是在 IT 软件产品的生命周期中，特别是产品开发基本完成到发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程。<br>安全测试也在越来越受到企业的关注和重视，因为由于安全性问题造成的后果是不可估量的。尤其对于互联网产品最容易遭受各种安全攻击。</p></li></ul><h1 id="适合自动化测试的项目"><a href="#适合自动化测试的项目" class="headerlink" title="适合自动化测试的项目"></a>适合自动化测试的项目</h1><ol><li>任务测试明确，不会频繁变动</li><li>每日构建后的测试验证</li><li>比较频繁的回归测试</li><li>软件系统界面稳定，变动少</li><li>需要在多平台上运行的相同测试案例、组合遍历型的测试、大量的重复任务</li><li>软件维护周期长</li><li>项目进度压力不太大</li><li>被测软件系统开发比较规范，能够保证系统的可测试性</li><li>具备大量的自动化测试平台</li><li>测试人员具备较强的编程能力</li></ol><h1 id="自动化测试工具"><a href="#自动化测试工具" class="headerlink" title="自动化测试工具"></a>自动化测试工具</h1><p>以下自动化测试工具均指UI自动化测试工具</p><ul><li><p><strong>QTP</strong><br>QTP 是 HP Quick Test Professional software 的简称，是一种企业级的自动测试工具。提供了强大<br>易用的录制回放功能。支持 B/S 与 C/S 两种架构的软件测试。是目前主流的自动化测试工具。</p></li><li><p><strong>Robot Framework</strong><br>Robot Framework 是一款 python 编写的功能自动化测试框架。具备良好的可扩展性，支持关键字驱动，<br>可以同时测试多种类型的客户端或者接口，可以进行分布式测试执行。</p></li><li><p><strong>watir</strong><br>Watir 全称是“Web Application Testing in Ruby”。它是一种基于 Web 模式的自动化功能测试工具。watir 是一个 ruby 语言库，使用 ruby 语言进行脚本开发。</p></li><li><p><strong>selenium</strong><br>Selenium 也是一个用于 Web应用程序测试的工具，支持多平台、多浏览、多语言去实现自动化测试。<br>目前在 web 自动化领域应用越来越广泛。<br>当然，除了上面所列自动化测试工外，根据不同的应用还有很多商业的、开源的以及公司自己开发的自动化测试工具。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 数据库基于LVM快照恢复</title>
      <link href="/mysql-restore/"/>
      <url>/mysql-restore/</url>
      
        <content type="html"><![CDATA[<p>MySQL LVM快照的二进制日志恢复。</p><a id="more"></a><h2 id="二进制日志的恢复"><a href="#二进制日志的恢复" class="headerlink" title="二进制日志的恢复"></a>二进制日志的恢复</h2><p>二进制日志非常关键，用户可以通过它完成<code>point-in-time</code>的恢复工作。MySQL数据库的replication同样需要二进制日志。  </p><p>要恢复二进制日志是非常简单的，通过mysqlbinlog即可。mysqlbinlog的使用方法如下：</p><pre><code>shell&gt;mysqlbinlog [options] logfile</code></pre><p>例如要还原binlog.000001，可以使用以下命令：</p><pre><code>shell&gt;mysqlbinlog binlog.000001 | mysql -h 171.17.0.2 -u root --password=pwd</code></pre><p>也可以先导出到一个sql文件，再用source命令来导入</p><pre><code>shell&gt;mysqlbinlog binlog.000001 &gt; /tmp/dump.sqlshell&gt;mysql -h 171.17.0.2 -u root --password=pwd -e &quot;source /tmp/dump.sql&quot;</code></pre><p>用<code>--start-position</code>和<code>--stop-position</code>选项可以选择特定位置的二进制日志。</p><h2 id="恢复场景"><a href="#恢复场景" class="headerlink" title="恢复场景"></a>恢复场景</h2><p>server1 <code>192.168.2.5</code> docker容器运行 mysql <strong>主数据库</strong><br>server2 <code>192.168.2.230</code> docker容器运行 mysql <strong>从数据库</strong></p><p>以下以<code>2.5</code>代称<code>192.168.2.5</code>,<code>2.230</code>代称<code>192.168.2.230</code>。</p><p>主从关系正常，每次主数据库的操作都会映射到从数据库，<br>且 从数据库的系统变量 <code>log_slave_updates=TRUE</code>（启用slave replication日志写入binlog）。</p><p><code>2.230</code> 的 mysql 数据文件 在 <code>/mnt1/data/mysql</code> 文件夹。</p><p><code>2.230</code> mysql 数据库每天使用 <code>lvm</code> 备份了一份 <code>mysql</code> 数据文件 如 <code>/mnt1/data/mysqlbak/20170214.tar.gz</code>。</p><h3 id="场景1-2-5误删数据同步到了2-230"><a href="#场景1-2-5误删数据同步到了2-230" class="headerlink" title="场景1 2.5误删数据同步到了2.230"></a>场景1 <code>2.5</code>误删数据同步到了<code>2.230</code></h3><p>昨天<code>2017-02-13 14:00:00</code> 数据库管理人员在<code>2.5</code>创建了数据库<code>test1</code> 而且写入了一些数据，<code>2.230</code>同步创建。</p><p>昨天<code>2017-02-13 23:00:00</code> 备份了一份数据文件<code>/mnt1/data/mysqlbak/20170213.tar.gz</code>，备份的时候，锁表后，通过<code>show master  status</code>已记录下最新<code>binlog</code>的<code>position</code>，解锁，存于<code>02170213.tar.gz/binpos.log</code>。</p><p>今天<code>2017-02-14 14:00:00</code>，由于数据库管理人员的失误，在<code>2.5</code> <code>test1</code>数据库删除了，<code>2.230</code>也同步了删除，这并不是数据库管理人员期望的结果，它希望在<code>2.230</code>上恢复<code>test1</code>数据库。</p><p>思路：将备份的数据文件完全覆盖现在的数据文件，然后通过恢复后继二进制日志来达到恢复的目的，备份时的二进制日志position作为start position到需要跳过的语句的posistion作为stop position。跳过后的语句作为start postion到二进制日志末尾。</p><p>创建临时文件夹</p><pre><code>root@192.168.2.230$ cd /mnt1/data/root@192.168.2.230$ mkdir -p tmpres/bakroot@192.168.2.230$ mkdir -p tmpres/old</code></pre><p>解压备份文件</p><pre><code>root@192.168.2.230$ tar -xzf /mnt1/data/mysqlbak/20170213.tar.gz -C /mnt1/data/</code></pre><p>拷贝现在的数据文件</p><pre><code>root@192.168.2.230$ cp -r /mnt1/data/mysql/* /mnt1/data/tmpres/old</code></pre><p>到此为止，数据库备份数据文件在 <code>/mnt1/data/tmpres/bak</code>， 数据库现在的数据文件在 <code>/mnt1/data/tmpres/old</code>。  </p><p>用备份数据覆盖现在的数据库数据</p><pre><code>root@192.168.2.230$ rm -rf /mnt1/data/mysql/*root@192.168.2.230$ cp -r /mnt1/data/tmpres/bak/* /mnt1/data/mysql</code></pre><p>查看备份时的binlog position</p><pre><code>root@192.168.2.230$ cat /mnt1/data/tmpres/bak/binpos.logFile: mysql-bin.000026 Position: 763Relay_Log_File: mysql-relay-bin.000026 Relay_Log_Pos: 837</code></pre><p>可以看到当时的binlog start position为763，现在只需要找出binlog stop postion，即需要略过的删数据库postion。</p><p>找出需要跳过的语句的position</p><pre><code>root@192.168.2.230$ mysqlbinlog /mnt1/data/mysql/old/mysql-bin.000026/*!*/;# at 895#170214 22:34:09 server id 1  end_log_pos 852 CRC32 0x4266be1d  Query   thread_id=319   exec_time=4294932166    error_code=0SET TIMESTAMP=1487082849/*!*/;DROP DATABASE `test1`/*!*/;# at 905...# at 1052#170214 12:49:30 server id 2  end_log_pos 899 CRC32 0x833b69af  Rotate to mysql-bin.000027  pos: 4SET @@SESSION.GTID_NEXT= &apos;AUTOMATIC&apos; /* added by mysqlbinlog */ /*!*/;DELIMITER ;# End of log file/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</code></pre><p>找到了drop database 的 postion 为895，所以start-postion=763,stop-position=895。下一段binlog的start-position=905,end-position=EOF 文件末尾。</p><pre><code>root@192.168.2.230$ mysqlbinlog --start-position=763 --stop-position=895 | mysql -h 171.17.0.2 -u root --password=pwdroot@192.168.2.230$ mysqlbinlog --startposition=905 | mysql -h 171.17.0.2 -u root --password=pwd</code></pre><p>从数据库已经恢复完成。</p><h3 id="场景2-主库备库切换"><a href="#场景2-主库备库切换" class="headerlink" title="场景2 主库备库切换"></a>场景2 主库备库切换</h3><p>当主库出现问题时，这时需要立即切换到备库，主要流程如下：</p><ol><li>限制主库访问，只有同步备库的角色才能访问。</li><li>确认备库是否同步完成并关闭replication功能。</li><li>关掉主库，程序正式使用备库。</li></ol><h4 id="1-主库设置限制访问"><a href="#1-主库设置限制访问" class="headerlink" title="1.主库设置限制访问"></a>1.主库设置限制访问</h4><p>锁表，只能读，不能写：</p><pre><code>mysql&gt; flush tables with read lock;</code></pre><h4 id="2-确认备库是否同步完成并关闭同步功能"><a href="#2-确认备库是否同步完成并关闭同步功能" class="headerlink" title="2.确认备库是否同步完成并关闭同步功能"></a>2.确认备库是否同步完成并关闭同步功能</h4><pre><code>mysql&gt; show slave status;mysql&gt; stop slave;</code></pre><p>如果<code>Slave_IO_State</code> 是 <code>Waiting for master to send event</code>， 说明已同步完成。</p><h4 id="3-关闭主库"><a href="#3-关闭主库" class="headerlink" title="3.关闭主库"></a>3.关闭主库</h4><pre><code>root@192.168.2.5$ service mysql stop</code></pre><p>关闭主库后，程序的连接设置成备库。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《高性能MySQL》</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 数据库基于LVM快照热备份</title>
      <link href="/mysql-backup/"/>
      <url>/mysql-backup/</url>
      
        <content type="html"><![CDATA[<p>MySQL 数据库的热备份 - 基于LVM快照备份。</p><a id="more"></a><h2 id="热备与冷备"><a href="#热备与冷备" class="headerlink" title="热备与冷备"></a>热备与冷备</h2><p>数据库的备份与恢复是一项最基本但是却不简单的工作，根据不同类型来划分备份的方法，划分出最基础的两种备份，热备与冷备。冷备是指在数据库停止的情况下，一般只需要复制相关数据库文件，而热备即在数据库运行的时候直接备份，对正在运行的数据库没有任何影响。 </p><p>以下通过两种备份来保证数据的安全，复制备份与快照备份。复制备份用于数据库实时备份，当开发人员对主数据库进行误操作时，其结果也会应用到从数据库，所以需要对从数据库进行快照(snapshot)来防止从数据库数据丢失。</p><h2 id="1-复制备份"><a href="#1-复制备份" class="headerlink" title="1. 复制备份"></a>1. 复制备份</h2><p>同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。  </p><p>其中二进制日志可用于MySQL数据库的备份，通过一个完全备份进行二进制日志的重做来完成数据库的point-in-time的恢复工作，MySQL数据库复制(replication)的原理就是异步实时地将二进制日志重做传送并应用到从数据库。</p><p>MySQL 复制是MySQL数据库提供的一种高可用高性能的解决方案，复制的原理并不难，其实就是一个完全备份加上二进制日志备份的还原。</p><h2 id="2-快照备份"><a href="#2-快照备份" class="headerlink" title="2. 快照备份"></a>2. 快照备份</h2><p><code>Logical Volume Manager (LVM)</code>提供了对任意一个<code>Logical Volume(LV)</code>做“快照”(snapshot)的功能，以此来获得一个分区的状态一致性备份。<br>在某一个状态下做备份的时候，可能有应用正在访问某一个文件或者数据库，这就是使得备份的时候文件处于一个状态，而备份完后，文件却处于另外一个状态，从而造成备份的非一致性，这种状态恢复数据库数据几乎不会成功。</p><p>状态的解决办法是将其分区挂载为只读，然后通过数据库的表级别锁定(table-level write locks)甚至停止数据库来备份数据。所有这些方法无意严重影响了服务的可用性。使用LVM snapshot既可以获得一致性备份，又不会影响服务器的可用性。</p><h2 id="3-开始备份"><a href="#3-开始备份" class="headerlink" title="3. 开始备份"></a>3. 开始备份</h2><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><p>有两台服务器<code>192.168.2.5</code>与<code>192.168.2.230</code>，在同一局域网，为了快速部署并且不影响操作系统，将使用<code>docker</code>作为运行<code>mysql</code>的容器。<br>从<code>docker hub</code>拉取或者自己制作一个镜像，这里已经在<code>192.168.2.5</code>制作好了一个镜像，并已经push到了<code>192.168.2.230</code>。</p><p>开始在<code>192.168.2.5</code> <strong>运行MySQL</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h mysql-server --restart=always --name=mysql_server -p 3306:3306 -v /mnt1/data/mysql:/mnt/data/mysql-online 192.168.2.230:5000/sunyuki/mysqllinux:latest</span><br></pre></td></tr></table></figure><p>这样会运行一个<code>docker</code>容器，并且将<code>docker</code>中的<code>mysql</code>数据库文件<code>mnt/data/mysql-online</code>挂载到了本地磁盘<code>/mnt1/data/mysql</code>。</p><p>同样的，在<code>192.168.2.230</code>执行相同的命令，这样在两台机器的运行的<code>mysql</code>是一样的，并且两个容器的名称是<code>mysql_server</code>。</p><h4 id="2-启用数据库二进制日志"><a href="#2-启用数据库二进制日志" class="headerlink" title="2.启用数据库二进制日志"></a>2.启用数据库二进制日志</h4><p>因为复制的原理是重做二进制日志，所以需要为两台机器都启用二进制日志。</p><p>两台机器都运行起<code>docker</code>容器后，连接到<code>192.168.2.5</code>进入<code>mysql_server</code>容器更改配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_server /bin/bash</span><br></pre></td></tr></table></figure><p>在数据库配置文件中设置(通常为<code>/etc/my.cnf</code>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">log</span>-bin = mysql-bin</span><br><span class="line">sync_binlog = 1</span><br><span class="line">innodb_support_xa = 1</span><br></pre></td></tr></table></figure><p>连接到<code>192.168.2.230</code>做同样的操作。</p><p>这样两台机器都启用了二进制日志。</p><h4 id="2-更改数据库-server-id"><a href="#2-更改数据库-server-id" class="headerlink" title="2.更改数据库 server-id"></a>2.更改数据库 server-id</h4><p>打算将<code>192.168.230</code>作为<strong>从服务器</strong>，<code>192.168.2.5</code>作为<strong>主服务器</strong>，需要将两台机器的数据库<code>server-id</code>更改的不一样。  </p><p>在<code>192.168.2.230</code>:<br>进入docker容器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_server /bin/bash</span><br></pre></td></tr></table></figure><p>更改数据库配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id = 2</span><br></pre></td></tr></table></figure><p>并且重命名<code>192.168.2.230</code>中的 <code>auto.cnf</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv auto.cnf auto.cnf.bak</span><br></pre></td></tr></table></figure><p>重命名这个文件的原因是这个文件定义了两台服务器的<code>uuid</code>，因为两台服务器的<code>docker</code>镜像是一样的，所以要让<code>mysql</code>重新生成<code>uuid</code>。</p><p><code>auto.cnf</code>中的内容一览:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[auto]</span><br><span class="line">server-uuid=9f31bddf-d965-11e6-9c77-0242ac110003</span><br></pre></td></tr></table></figure><p>重启<code>mysql</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p>在<code>192.168.2.5</code>:<br>进入docker容器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql_server /bin/bash</span><br></pre></td></tr></table></figure>    <p>更改数据库配置文件:</p><pre><code>[mysqld]server-id = 1</code></pre><p>重启<code>mysql</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>    <h4 id="3-配置主从数据库"><a href="#3-配置主从数据库" class="headerlink" title="3.配置主从数据库"></a>3.配置主从数据库</h4><p>在<code>192.168.2.5</code>:<br>进入<code>192.168.2.5</code>的<code>docker</code>容器:<br>创建新用户用于复制功能:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER <span class="string">'repl'</span>@<span class="string">'192.168.2.230'</span> IDENTIFIED BY <span class="string">'repl'</span>;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">'repl'</span>@<span class="string">'192.168.2.230'</span>;</span><br></pre></td></tr></table></figure><p>如果想看一下结果，可以查看<code>mysql</code>用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select user,host from mysql.user;</span><br></pre></td></tr></table></figure><p>首先查询主数据库日志文件位置:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status</span><br><span class="line"></span><br><span class="line">| file             | position |</span><br><span class="line">| mysql-bin.000017 | 120      |</span><br></pre></td></tr></table></figure><p>获取到两个重要的信息，二进制日志文件名与执行位置  </p><p>在<code>192.168.2.230</code>:<br>进入<code>192.168.2.230</code>的<code>docker</code>容器:<br>配置从服务器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">MASTER_HOST =<span class="string">'192.168.2.5'</span>,</span><br><span class="line">MASTER_USER =<span class="string">'repl'</span>,</span><br><span class="line">MASTER_PASSWORD =<span class="string">'repl'</span>,</span><br><span class="line">MASTER_LOG_FILE =<span class="string">'mysql-bin.000017'</span>,</span><br><span class="line">MASTER_LOG_POS =120;</span><br></pre></td></tr></table></figure><p>其中<code>MASTER_LOG_FILE</code>与<code>MASTER_LOG_POS</code>要与主数据库中的<code>show master status</code>的结果一致。</p><p>开启从数据库:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure><p>查看是否配置成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status;</span><br><span class="line"></span><br><span class="line">| Slave_IO_Running | Slave_SQL_Running | Last_IO_Error | Last_SQL_Error|</span><br><span class="line">| yes              | yes               |               |               |</span><br></pre></td></tr></table></figure><p>如果<code>Slave_SQL_Running</code>与<code>Slave_IO_Running</code>其中一个不是<code>yes</code>，就没有配置成功，具体错误可以在<code>Last_IO_Error</code>和<code>Last_SQL_Error</code>中查看。</p><p>依据这个原理，可以写一个脚本用户实时的去检查主从数据库是不是出错，如果出错了就发邮件给管理者，这里使用的是<code>python</code>写的脚本。</p><p>安装<code>mysql-connector for python</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/Connector-Python/mysql-connector-python-2.1.5-1.el6.x86_64.rpm</span><br><span class="line">rpm -i mysql-connector-python-2.1.5-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><p>安好connector后开始写<code>python</code>脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql</span></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">USER = <span class="string">'xxx'</span></span><br><span class="line">PASSWORD = <span class="string">'xxxx'</span></span><br><span class="line">LOG_FILE = <span class="string">'/var/log/mysqlchk.log'</span></span><br><span class="line">TIME_GAP = <span class="number">120</span>  <span class="comment"># interval time gap (unit seconds)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># smtp</span></span><br><span class="line">mailto_list = [<span class="string">"me@qq.com"</span>]</span><br><span class="line">mail_host = <span class="string">"smtp.domain.com"</span></span><br><span class="line">mail_user = <span class="string">"xxx"</span></span><br><span class="line">mail_pass = <span class="string">"xxx"</span></span><br><span class="line">mail_postfix = <span class="string">"domain.com"</span></span><br><span class="line">mail_nick_name = <span class="string">'MySQL CHK'</span></span><br><span class="line">mail_subject = <span class="string">'[ERROR] MySQL Replication Error'</span></span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"><span class="comment"># create a file handler</span></span><br><span class="line">handler = logging.FileHandler(LOG_FILE)</span><br><span class="line">handler.setLevel(logging.INFO)</span><br><span class="line"><span class="comment"># create a logging format</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">handler.setFormatter(formatter)</span><br><span class="line"><span class="comment"># add the handlers to the logger</span></span><br><span class="line">logger.addHandler(handler)</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">'program start'</span>)</span><br><span class="line">cnx = mysql.connector.connect(user=USER, password=PASSWORD, host=HOST)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span><span class="params">(to_list, sub, content)</span>:</span></span><br><span class="line">    me = mail_nick_name + <span class="string">"&lt;"</span> + mail_user + <span class="string">"@"</span> + mail_postfix + <span class="string">"&gt;"</span></span><br><span class="line">    msg = MIMEText(content, _subtype=<span class="string">'plain'</span>, _charset=<span class="string">'gb2312'</span>)</span><br><span class="line">    msg[<span class="string">'Subject'</span>] = sub</span><br><span class="line">    msg[<span class="string">'From'</span>] = me</span><br><span class="line">    msg[<span class="string">'To'</span>] = <span class="string">";"</span>.join(to_list)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server = smtplib.SMTP()</span><br><span class="line">        server.connect(mail_host)</span><br><span class="line">        server.login(mail_user, mail_pass)</span><br><span class="line">        server.sendmail(me, to_list, msg.as_string())</span><br><span class="line">        server.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> str(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">()</span>:</span></span><br><span class="line">        logger.info(<span class="string">'start check slave status..'</span>)</span><br><span class="line">        cur = cnx.cursor()</span><br><span class="line">        query = (<span class="string">"show slave status"</span>)</span><br><span class="line">        cur.execute(query)</span><br><span class="line">        res = cur.fetchone()</span><br><span class="line">        (slave_io_running, slave_sql_running, last_io_error) = (res[<span class="number">10</span>], res[<span class="number">11</span>], res[<span class="number">35</span>])</span><br><span class="line">        <span class="keyword">if</span> slave_io_running != <span class="string">'yes'</span> <span class="keyword">and</span> slave_sql_running != <span class="string">'yes'</span>:</span><br><span class="line">            error = <span class="string">'[ERROR]Slave Error:&#123;0&#125;'</span>.format(last_io_error);</span><br><span class="line">            logger.error(error)</span><br><span class="line">            send_mail(mailto_list, mail_subject, error)</span><br><span class="line">        cur.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        check()</span><br><span class="line">        time.sleep(TIME_GAP)</span><br><span class="line"><span class="keyword">except</span> Exception, e:</span><br><span class="line">    logger.error(str(e))</span><br><span class="line">    send_mail(mailto_list, mail_subject, str(e))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    cnx.close</span><br><span class="line">    logger.info(<span class="string">'program terminate'</span>)</span><br></pre></td></tr></table></figure><p>这个脚本的用处就是每两分钟去检测主从服务器连接是否正常，如果不正常将会发送错误消息给管理员。<br>到这里主从数据库配置就完成了，可以通过连接<code>192.168.2.5</code>，执行数据库创建操作，然后再到<code>192.168.2.230</code>看新的数据库是否创建来试验<code>mysql</code>的复制(replication)功能。</p><h4 id="4-自动创建快照"><a href="#4-自动创建快照" class="headerlink" title="4.自动创建快照"></a>4.自动创建快照</h4><p>这一步开始在<strong>从数据库</strong>所在服务器<code>192.168.2.230</code>的数据库文件进行快照的操作，其实这一步之前，将<code>mysql</code>的数据库文件路径<code>/mnt1/data/mysql</code>挂载到了一个专用的LVM逻辑卷。<br>在<code>192.168.2.230</code>执行（不进入<code>docker</code>):<br>查看分区:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@syk230# fdisk -l</span><br><span class="line">    Device     Boot   Start        End    Sectors  Size Id Type</span><br><span class="line">/dev/sda1  *       2048     999423     997376  487M 83 Linux</span><br><span class="line">/dev/sda2       1001470 3907028991 3906027522  1.8T  5 Extended</span><br><span class="line">/dev/sda5       1001472 3907028991 3906027520  1.8T 8e Linux LVM</span><br></pre></td></tr></table></figure><p>查看卷组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@syk230# vgdisplay</span><br><span class="line">      --- Volume group ---</span><br><span class="line">  VG Name               syk230-vg</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  52</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                4</span><br><span class="line">  Open LV               3</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               1.82 TiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              476809</span><br><span class="line">  Alloc PE / Size       11076 / 43.27 GiB</span><br><span class="line">  Free  PE / Size       465733 / 1.78 TiB</span><br><span class="line">  VG UUID               brRcUd-vF1G-rWjH-EJW5-jiWG-fsrN-j2RtlN</span><br></pre></td></tr></table></figure><p>在<code>syk230-vg</code>卷组上创建一个名为<code>mysql</code>的逻辑卷，大小为3G:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 3G -n mysql syk230-vg</span><br></pre></td></tr></table></figure><p>查看逻辑卷:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@syk230# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/syk230-vg/mysql</span><br><span class="line">  LV Name                mysql</span><br><span class="line">  VG Name                syk230-vg</span><br><span class="line">  LV UUID                09gVIy-r0vY-rGrX-G6sf-EDm4-483o-ZDaO66</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time syk230, 2017-01-12 12:16:22 +0800</span><br><span class="line">  LV snapshot status     source of</span><br><span class="line">                         mysqlsnap [active]</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                3.00 GiB</span><br><span class="line">  Current LE             768</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           252:2</span><br></pre></td></tr></table></figure><p>格式化分区(ext4):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/syk230-vg/mysql</span><br></pre></td></tr></table></figure><p>挂载分区:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><p>添加内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/syk230--vg-mysql /mnt1/data/mysql ext4 defaults 0 2</span><br></pre></td></tr></table></figure><p>至此，为存储mysql数据逻辑卷创建好了。<br><strong>编写自动创建备份的脚本</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">tmppath=/mnt1/data/mysqlbak1</span><br><span class="line">bakpath=/mnt1/data/mysqlbak</span><br><span class="line">filename=`date +%Y%m%d.tar.gz`</span><br><span class="line">binpos=/tmp/binpos.log</span><br><span class="line"></span><br><span class="line">mysql -h 172.17.0.2 -u zyl --password=zyl -e <span class="string">"flush tables with read lock"</span></span><br><span class="line">mysql -h 172.17.0.2 -u zyl --password=zyl -e <span class="string">"show master status\G"</span> | grep <span class="string">'File\|Position'</span> | xargs &gt; <span class="variable">$binpos</span></span><br><span class="line">mysql -h 172.17.0.2 -u zyl --password=zyl -e <span class="string">"show slave status\G"</span> | grep <span class="string">'Relay_Log_File\|Relay_Log_Pos'</span> | xargs &gt;&gt; <span class="variable">$binpos</span></span><br><span class="line">lvcreate -s -n mysqlsnap1 -L 5G /dev/syk230-vg/mysql</span><br><span class="line">mysql -h 172.17.0.2 -u zyl --password=zyl -e <span class="string">"unlock tables"</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$tmppath</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        mkdir <span class="variable">$tmppath</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$bakpath</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        mkdir <span class="variable">$bakpath</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">mount /dev/syk230-vg/mysqlsnap1 <span class="variable">$tmppath</span></span><br><span class="line">mv <span class="variable">$binpos</span> <span class="variable">$tmppath</span></span><br><span class="line">tar -czf <span class="string">"<span class="variable">$bakpath</span>/<span class="variable">$filename</span>"</span> -C <span class="variable">$tmppath</span> .</span><br><span class="line">umount <span class="variable">$tmppath</span></span><br><span class="line">rmdir <span class="variable">$tmppath</span></span><br><span class="line">lvremove -f /dev/syk230-vg/mysqlsnap1</span><br></pre></td></tr></table></figure><p>其中<code>172.17.0.2</code>是<code>docker</code>中<code>mysql_server</code>容器本机内网ip。可以通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure><p>查询。<br>将执行脚本计划添加到<code>crontab</code>中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>添加内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /bin/bash /mnt1/data/mysqlbak.sh</span><br></pre></td></tr></table></figure><p>这样每天凌晨备份一次数据库，并且不需要停止数据库。</p><p><strong>删除30天之前的备份</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /mnt1/data/mysqlbak -mtime +30 -delete &gt; /mnt1/data/mysqldel.sh</span><br><span class="line">chmod 755 /mnt1/data/mysqldel.sh</span><br></pre></td></tr></table></figure><p>crontab 添加内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /bin/bash /mnt1/data/mysqldel.sh</span><br></pre></td></tr></table></figure><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>总的说来，配置MySQL的复制功能比配置LVM简单太多,主要是因为是否能正确的使用LVM快照功能跟硬盘配置选项有直接的关系，主要有以下几点需要注意到： </p><ul><li>安装系统的时候要选LVM管理的磁盘</li><li>安装系统分区的时候<strong>一定不要将系统分区占满整个磁盘</strong>，否则LVM无法分配新的空间来创建逻辑卷，且系统分区不可删除和缩小(否则需要用<code>cd-live</code>或者<code>usb-live</code>)</li><li>添加新硬盘的时候用<code>pvcreate</code>,<code>vgcreate</code>分别来创建物理卷和卷组</li><li>如果安装系统时没有选择LVM，用<code>fdisk</code>创建新的分区并且更改磁盘类型为<code>8e</code>(LVM类型代码)</li></ul><p>结合MySQL的复制功能和LVM的快照功能，既能保证数据的实时同步，又能防止程序或数据库管理员的误操作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《高性能MySQL》</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 盒子模型</title>
      <link href="/cssmodel/"/>
      <url>/cssmodel/</url>
      
        <content type="html"><![CDATA[<style>.img-desc{    font-size:10px;    color:#555;}</style><p>块元素与行内元素的盒子模型区别。</p><a id="more"></a><h2 id="基本框"><a href="#基本框" class="headerlink" title="基本框"></a>基本框</h2><p>CSS假定每个元素都会生成一个或多个矩形框，这些成为元素框。<br>各个元素框中心有一个内容区（<strong>content area</strong>），内容区周围有可选的内边距、边框和外边距。内边距不能是负值，但是外边距可以。外边距通常是透明的。</p><center><br><img src="/images/box.png" alt="box-model"><br><div class="img-desc">盒子模型</div><br></center><p>元素的<code>width</code>被认为从左内边界到右边界的距离，<code>height</code>是从上内边界到下内边界的距离。也就是说，元素的<code>width</code>与<code>height</code>不包含<code>padding、margin</code>。</p><p>讨论盒子模型之前需要先了解一些术语:  </p><ul><li>正常流 : 大多数元素从左向右、从上向下显示，要让一个元素不在正常流中，唯一的办法就是使之成为浮动或者定位元素。</li><li>非替换元素 ： 元素包含在文档中，如<code>em</code>, <code>a</code>。</li><li>替换元素 ： 作为其他内容的一个占位符，如<code>img</code>，大多数表单也可以替换，如<code>&lt;input type=&quot;radio&quot; /&gt;</code>。</li><li>块级元素 ： 指段落、标题或者div之类的元素，这些元素会在正常流中，会在其框之前和之后产生<quote>“换行”</quote>。</li><li>行内元素 ： 指storng或者span之类的元素。不会在元素前后生成“行分隔符”。</li><li>根元素 ： html元素。</li></ul><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><h2 id="水平格式化"><a href="#水平格式化" class="headerlink" title="水平格式化"></a>水平格式化</h2><h4 id="水平属性"><a href="#水平属性" class="headerlink" title="水平属性"></a>水平属性</h4><p>块级元素水平共有7个宽度，其总宽度为  </p><p><code>total-width = width + margin-left + margin-right + border-left + border-right + padding-left + padding-right</code></p><p>共7个宽度，其中 <code>margin-left</code>, <code>magin-right</code>, <code>width</code> 可以设置为<strong>auto</strong>。</p><h4 id="使用auto"><a href="#使用auto" class="headerlink" title="使用auto"></a>使用auto</h4><p>块级元素水平属性中<code>margin-left</code>, <code>magin-right</code>, <code>width</code> 可以设置为<strong>auto</strong>，意思就是浏览器自动计算其值，当其中有两个值确定了，第三个值就会被设置为占满父元素剩下所需的宽度。</p><ul><li>当3个属性没有一个为<strong>auto</strong>，那么这种格式化属性“过分受限”，此时，浏览器会将<code>margin-right</code>设置为<strong>auto</strong>，此时右外边距将“填补”所需的距离。</li><li>当3个属性都为<strong>auto</strong>时，就是默认块元素所显示的那样。</li></ul><h4 id="设置元素水平居中"><a href="#设置元素水平居中" class="headerlink" title="设置元素水平居中"></a>设置元素水平居中</h4><p>当<code>margin-left</code>, <code>magin-right</code>, <code>width</code>其中有二个设置了明确的值，第三个属性设置为<strong>auto</strong>时，会使第三个属性的宽度确定所需的长度，从而使元素狂的宽度等于父元素的width。<br>所以设置元素的宽度再使左右外边距为<strong>auto</strong>，即  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">margin-left</span><span class="selector-pseudo">:auto</span>;<span class="selector-tag">margin-right</span><span class="selector-pseudo">:auto</span>;<span class="selector-tag">width</span><span class="selector-pseudo">:100px</span></span><br></pre></td></tr></table></figure><p>这样就能使元素的左右两边外边距自动计算从而实现居中。这样与<code>text-align:center</code>的区别就是，text-align只能应用于块级元素中的<strong>内联元素</strong>。</p><h2 id="垂直格式化"><a href="#垂直格式化" class="headerlink" title="垂直格式化"></a>垂直格式化</h2><h4 id="垂直属性"><a href="#垂直属性" class="headerlink" title="垂直属性"></a>垂直属性</h4><p>块级元素水平共有7个高度，其总高度为  </p><p><code>total-height = height + margin-top + margin-bottom + border-top + border-bottom + padding-top + padding-bottom</code></p><p>共7个高度，其中 <code>margin-top</code>, <code>magin-bottom</code>, <code>height</code> 可以设置为<strong>auto</strong>，<strong>遗憾的是</strong>，<code>margin-top</code>和<code>margin-bottom</code>为auto时，会被自动解析为0，所以很不容易让正常流元素居中。高度为<strong>auto</strong>时，其高度为内容的高度。</p><h4 id="使用auto-1"><a href="#使用auto-1" class="headerlink" title="使用auto"></a>使用auto</h4><p>高度使用<strong>auto</strong>会使之适应子元素的内容高度，而外边距使用<strong>auto</strong>会使外边距为0。</p><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><p>将元素居中的唯一办法就是把上下边距都设置为25%。</p><h4 id="合并垂直外边距"><a href="#合并垂直外边距" class="headerlink" title="合并垂直外边距"></a>合并垂直外边距</h4><p>垂直相邻外边距会合并，以较大者为总的垂直外边距。<strong>但是</strong>如果元素有内边距和外边距，他们绝对不会合并。<br>考虑下面的情况：</p><div style="height: auto;background: silver"><br>    <p style="margin-top: 2em; margin-bottom: 2em;">A paragraph!</p><br></div><br><div style="height: auto;background: silver;border-top:1px solid;border-bottom: 1px solid;"><br>    <p style="margin-top: 2em; margin-bottom: 2em;">Another paragraph!</p><br></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: auto;background: silver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"margin-top: 2em; margin-bottom: 2em;"</span>&gt;</span>A paragraph!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: auto;background: silver;border-top:1px solid;border-bottom: 1px solid;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"margin-top: 2em; margin-bottom: 2em;"</span>&gt;</span>Another paragraph!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当父元素高度为<strong>auto</strong>，仅包含块级子元素，并且没有内边距或者边框，这时子元素的外边距将会“<strong>超出</strong>”父元素。</p><h2 id="块级替换元素"><a href="#块级替换元素" class="headerlink" title="块级替换元素"></a>块级替换元素</h2><p>块级替换元素，如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'test.png'</span> <span class="attr">style</span>=<span class="string">'display:block'</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>与块级非替换元素的区别就是，设置<code>width:auto、height:auto</code>时，其高度宽度为元素都是替换内容的固有宽度高度。</p><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><ul><li>匿名文本：顾名思义，未包含在行内元素的文本如 <code>&lt;div&gt;anonymous text&lt;/div&gt;</code></li><li>em框：也称为字符框，实际字体可能比em框大或者小，<code>font-size</code> 决定了em框的大小</li><li>内容区：即em框，如果是替换元素，就是元素的固有高度加上外边距、边框和内边距</li><li>行间距(leading)：是font-size与line-height之差，这个差实际上要分成两半，分别应用于内容区的顶部和底部，为内容区增加的这两部分分别称为半间距(half-leading)。行间距只适用于非替换元素</li><li>行内框：内容区加上行间距，对于非替换元素，刚好等于line-height，对于替换元素，恰好等于内容区的高度，因为line-height不适用于替换元素</li><li>行框：包含该行中出现的行内框的最高点和最低点的小框，换句话说，就是该行的总共高度（上边界到下边界）</li></ul><h4 id="行内替换元素"><a href="#行内替换元素" class="headerlink" title="行内替换元素"></a>行内替换元素</h4><p>替换元素可以增加行框的高度，但不影响line-height的值，然而，替换元素还是有一个line-height值，因为要用于vertical-align的计算。</p><h2 id="块级元素VS行内元素"><a href="#块级元素VS行内元素" class="headerlink" title="块级元素VS行内元素"></a>块级元素VS行内元素</h2><ul><li>块级元素的背景应用于整个元素包括外边距，而行内元素的背景应用于内容区和内边距</li><li>行内非替换元素的内外边距、边框没有垂直效果，而块级元素则有</li><li>行内元素不能设置其width、height</li></ul><h2 id="替换元素的特殊之处"><a href="#替换元素的特殊之处" class="headerlink" title="替换元素的特殊之处"></a>替换元素的特殊之处</h2><ul><li>块级替换元素的width或height为auto时，刚好是图片的宽度与高度</li><li>行内替换元素的内外边距、边框有垂直效果</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><code>内容区</code> 为CSS属性中的 <code>width</code> 和 <code>height</code> ，并不包括内外边距与边框</li><li>背景色包括 <code>内边距</code> 和 <code>内容区</code> ，但不包括 <code>外边距</code></li><li>块级元素的 <code>height</code> 为auto时，高度为内容区大小</li><li>块级元素的 <code>width</code> 尽可能的占满父元素</li><li>块级元素<strong><em>水平方向</em></strong> <code>margin</code> 为<strong>auto</strong>时， 会尽可能的占满父元素</li><li>块级元素<strong><em>水平居中</em></strong> <code>margin-left:auto, margin-right: auto, width: 100px</code> </li><li>块级元素<strong><em>垂直方向</em></strong> <code>margin</code> 为<strong>auto</strong>时， 会被自动解析为0</li><li>块级元素<strong><em>垂直方向</em></strong> <code>margin</code> 会<strong>合并</strong></li><li>块级元素仅包含块级子元素时，如果没有设置 <code>padding</code> 、 <code>border</code> 与 <code>height</code> ，父元素<strong><em>垂直方向</em></strong>的 <code>margin</code> 会与 子元素垂直方向的 <code>margin</code> <strong>合并</strong>。</li><li>块级元素<strong><em>垂直居中</em></strong> <code>margin</code> 不容易居中，唯一办法就是设置上下外边距为25%</li><li>块级<strong><em>替换元素</em></strong>的高度宽度由替换内容决定</li><li>行内元素不能包含块元素（XHTML定义的就是这样）</li><li>行内元素没有 <code>width</code> 和 <code>height</code> ，也没有垂直方向的 <code>margin</code></li><li>行内元素的内边距和边框不改变行高，边框边界由<code>font-size</code>（em框）决定，而不是<code>line-height</code></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《CSS权威指南》</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
